# 创建计算器级别的语言

在这一章中，作为C编译器创建的第一个步骤，我们要支持四则运算和其他算术运算符，使得能够编译如下所示的表达式：`30 + (4 - 2) * -5`。

这看起来可能是个不起眼的目标，但实际上实现起来颇有难度。数学表达式存在诸如括号内的表达式优先计算、乘法优先于加法等结构，要正确计算就必须理解这些规则。然而，作为输入的数学表达式只是一串扁平的字符，并非结构化的数据。要正确地对表达式进行求值，需要解析字符的排列，从中推导出隐藏的结构。

如果没有任何前提知识，解决这类语法解析问题会相当困难。事实上，这类问题在过去被认为是难题，特别是在20世纪50年代到70年代期间，研究者们进行了大量研究，开发出了各种算法。得益于这些成果，如今只要掌握了方法，语法解析就不再是那么困难的问题了。

在这一章中，我们将介绍一种最常用的语法解析算法——“递归下降解析法”（recursive descent parsing）。大家日常使用的GCC、Clang等C/C++编译器，也采用了递归下降解析法。

不仅限于编译器，在编程过程中，读取具有某种结构的文本这类任务经常会遇到。本章所学的技术可以直接应用于这类问题。毫不夸张地说，本章学习的语法解析技巧，在编程领域能起到举一反三的作用。希望大家通过阅读本章理解这种算法，将语法解析的技能纳入自己的编程工具箱。

## 步骤1：创建能编译单个整数的语言

请思考一下最简单的C语言子集。大家会想到什么样的语言呢？是只有main函数的语言，还是只由一个表达式构成的语言？深入思考的话，由单个整数构成的语言，可以说是能想到的最简单的子集了。

在这个步骤中，我们首先来实现这种最简单的语言。

这个步骤要创建的程序是一个编译器，它从输入中读取一个数字，然后输出将该数字作为程序退出码的汇编代码。也就是说，输入是像42这样的字符串，读取后会输出如下所示的汇编代码：

```asm
.intel_syntax noprefix
.globl main
main:
  mov rax, 42
  ret
```

`.intel_syntax noprefix`是在多种汇编写法中，选择本书所使用的Intel记法的汇编命令。本次创建的编译器务必在开头加上这一行。其他行的含义如前章所述。

或许大家会觉得“这样的程序算不上编译器”，说实话，笔者也有同感。但是，这个程序接收由单个数值构成的语言作为输入，并输出对应的代码，从定义上来说，它确实是一个合格的编译器。这样简单的程序经过改造，很快就能实现相当复杂的功能，所以先完成这个步骤吧。

实际上，从整个开发流程来看，这个步骤非常重要，因为我们会将这里制作的内容作为基础，继续后续的开发。在这个步骤中，除了编译器本体的创建，我们还要进行编译脚本（Makefile）、自动测试的创建以及git仓库的设置。我们逐一来看这些工作。

另外，本书中创建的C编译器名为9cc。cc是C compiler（C编译器）的缩写。数字9没有特殊含义，因为笔者之前制作的C编译器名为8cc，所以这个就作为后续作品命名为9cc。大家当然也可以起自己喜欢的名字。不过，不要因为过于纠结名字而迟迟不开始编译器的创建。包括GitHub仓库在内，名字都可以后续更改，所以先用一个临时的名字开始也没问题。

> **注：Intel记法与AT&T记法**
>
> 除了本书使用的Intel记法，AT&T记法在以Unix为中心的领域也被广泛使用。gcc和objdump默认以AT&T记法输出汇编代码。
>
> 在AT&T记法中，结果寄存器位于第二个参数的位置。因此，对于两个参数的指令，参数的书写顺序是相反的。寄存器名前要加%前缀，写成%rax这样的形式。数值前要加$前缀，写成$42这样的形式。
>
> 此外，引用内存时，不使用[]而使用()，并以独特的记法描述表达式。下面为了对比，举几个例子：
>
> ```asm
> ; Intel记法               ; AT&T记法
> mov rbp, rsp              ; mov %rsp, %rbp
> mov rax, 8                ; mov $8, %rax
> mov [rbp + rcx * 4 - 8], rax ; mov %rax, -8(rbp, rcx, 4)
> ```
>
> 本次创建的编译器考虑到可读性，选择使用Intel记法。Intel的指令集手册使用Intel记法，因此可以将手册中的描述直接写入代码，这也是其优点之一。AT&T记法和Intel记法的表达能力相同，使用任何一种记法，生成的机器语言指令序列都是相同的。

### 编译器本体的创建

通常，编译器以文件作为输入，但这里为了避免打开文件读取的麻烦，我们直接将代码作为命令的第一个参数传入。将第一个参数作为数值读取，并嵌入到固定格式的汇编代码中的C程序，可以简单地写成如下形式：

```c
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char **argv) {
  if (argc != 2) {
    fprintf(stderr, "参数个数不正确\n");
    return 1;
  }

  printf(".intel_syntax noprefix\n");
  printf(".globl main\n");
  printf("main:\n");
  printf("  mov rax, %d\n", atoi(argv[1]));
  printf("  ret\n");
  return 0;
}
```

创建一个名为9cc的空目录，在其中创建名为9cc.c的文件，内容如上。然后执行如下命令，确认9cc的运行情况：

```bash
cc -o 9cc 9cc.c
./9cc 123 > tmp.s
```

第1行编译9cc.c，生成名为9cc的可执行文件。第2行将123作为输入传给9cc，生成汇编代码，并写入tmp.s文件。我们来确认一下tmp.s的内容：

```bash
$ cat tmp.s
.intel_syntax noprefix
.globl main
main:
  mov rax, 123
  ret
```

如所见，代码生成成功了。将生成的汇编文件交给汇编器，就能创建可执行文件。

在Unix中，cc（或gcc）不仅用于C和C++，还被视为多种语言的前端入口，会根据给定文件的扩展名判断语言，并调用相应的编译器或汇编器。因此，这里像编译9cc时一样，将扩展名为.s的汇编文件传给cc，就能进行汇编操作。下面是进行汇编并执行生成的可执行文件的例子：

```bash
$ cc -o tmp tmp.s
$ ./tmp
$ echo $?
123
```

如前所述，shell中可以通过$?变量访问上一条命令的退出码。在上面的例子中，显示了与传给9cc的参数相同的123，说明程序正常运行。

### 自动测试的创建

很多读者可能在兴趣编程中从未写过测试，但在本书中，每次扩展编译器时，都要编写测试代码来测试新功能。一开始可能会觉得写测试很麻烦，但很快就会体会到测试的好处。如果不写测试代码，最终还是要手动执行相同的测试来确认运行情况，而手动操作要麻烦得多。

人们对测试的麻烦印象，很大程度上来自测试框架过于复杂，或者测试理念有时过于教条。例如，JUnit之类的测试框架虽然有各种便利功能，但学习和引入都需要花费功夫。因此，本章不会引入这类测试框架，而是用手写的非常简单的“测试框架”——shell脚本，来进行测试。

下面是测试用的shell脚本test.sh。shell函数assert接收两个参数：预期输出值和输入值，它会实际通过9cc进行编译，将结果与预期值比较。在shell脚本中，定义assert函数后，用它来确认0和42都能正确编译：

```bash
#!/bin/bash

assert() {
  expected="$1"
  input="$2"

  ./9cc "$input" > tmp.s
  cc -o tmp tmp.s
  ./tmp
  actual="$?"

  if [ "$actual" = "$expected" ]; then
    echo "$input => $actual"
  else
    echo "$input => $expected expected, but got $actual"
    exit 1
  fi
}

assert 0 0
assert 42 42

echo OK
```

创建上述内容的test.sh文件，执行`chmod a+x test.sh`使其可执行。实际运行test.sh看看，如果没有错误，test.sh最后会显示OK：

```bash
$ ./test.sh
0 => 0
42 => 42
OK
```

如果出现错误，test.sh不会显示OK，而是会像下面这样，显示失败测试的预期值和实际值：

```bash
$ ./test.sh
0 => 0
42 expected, but got 123
```

想要调试测试脚本时，可以给bash加上-x选项执行脚本。加上-x选项后，bash会像下面这样显示执行轨迹：

```bash
$ bash -x test.sh
+ assert 0 0
+ expected=0
+ input=0
+ ./9cc 0
+ cc -o tmp tmp.s
+ ./tmp
+ actual=0
+ '[' 0 = 0 ']'
+ echo '0 => 0'
0 => 0
+ assert 42 42
+ expected=42
+ input=42
+ ./9cc 42
+ cc -o tmp tmp.s
+ ./tmp
+ actual=42
+ '[' 42 = 42 ']'
+ echo '42 => 42'
42 => 42
+ echo OK
OK
```

我们在本书中使用的“测试框架”就是这样的shell脚本。与JUnit等成熟的测试框架相比，这个shell脚本可能显得过于简单，但这种简单性与9cc自身的简单性相匹配，反而更为合适。自动测试的关键在于，能够一键运行自己编写的代码，并机械地比较结果，所以不必想得太复杂，先进行测试才是最重要的。

### 使用make进行构建

在阅读本书的过程中，大家会编译9cc数百次甚至数千次。由于创建9cc的可执行文件并运行测试脚本的操作每次都相同，交给工具来做会很方便。make命令就是用于这种场景的标准工具。

执行make命令时，它会读取当前目录下名为Makefile的文件，并执行其中编写的命令。Makefile由以冒号分隔的行和该行为之执行的命令序列构成。下面的Makefile用于自动执行本步骤中想要执行的命令：

```makefile
CFLAGS=-std=c11 -g -static
9cc: 9cc.c
test: 9cc
  ./test.sh
clean:
  rm -f 9cc *.o *~ tmp*
.PHONY: test clean
```

将上述内容的文件以Makefile为名，创建在9cc.c所在的目录中。这样，只需执行make就能创建9cc，执行make test就能运行测试。make能够理解文件的依赖关系，因此修改9cc.c后，执行make test前无需再执行make，只要9cc这个可执行文件比9cc.c旧，make就会在执行测试前先编译9cc。

make clean是删除临时文件的规则。虽然也可以手动rm删除临时文件，但为避免误删不想删除的文件，这类实用操作也写在Makefile中。

需要注意的是，Makefile中的缩进必须使用制表符（tab），使用4个或8个空格会导致错误。这只是语法上的不便，因为make是20世纪70年代开发的古老工具，传统上就是这样设计的。

请务必给cc传递-static选项。这个选项的含义会在“静态链接与动态链接”这一章中说明，现在不必特别考虑。

### 使用git进行版本管理

本书使用git作为版本管理系统。在本书中，我们会分步骤制作编译器，每个步骤都要进行git提交，并编写提交消息。提交消息可以用日语，用一行简洁地总结实际的修改内容。如果想写一行以上的详细说明，在第一行之后空一行再写即可。

使用git进行版本管理的仅包括自己手动生成的文件。像9cc运行生成的文件等，因为执行相同命令可以重新生成，所以不需要纳入版本管理。实际上，如果纳入这类文件，每次提交的变更点会不必要地变长，因此需要将它们排除在版本管理之外，不加入仓库。

在git中，可以在名为.gitignore的文件中写入要排除在版本管理之外的文件模式，让git忽略临时文件和数据备份文件等。例如：

```txt
*~
*.o
tmp*
a.out
9cc
```

初次使用git的人，需要告诉git自己的名字和邮箱地址。这里设置的名字和邮箱会记录在提交日志中。下面是设置笔者名字和邮箱的例子，请大家设置自己的信息：

```bash
git config --global user.name "Rui Ueyama"
git config --global user.email "ruiu@cs.stanford.edu"
```

要进行git提交，首先需要用git add将有变更的文件添加进去。由于这是首次提交，先通过git init创建git仓库，然后添加到目前为止创建的所有文件：

```bash
$ git init
Initialized empty Git repository in /home/ruiu/9cc
$ git add 9cc.c test.sh Makefile .gitignore
```

然后用git commit进行提交：

```bash
git commit -m "创建能编译单个整数的编译器"
```

通过-m选项指定提交消息。如果没有-m选项，git会启动编辑器。执行`git log -p`可以确认提交是否成功：

```bash
$ git log -p
commit 0942e68a98a048503eadfee46add3b8b9c7ae8b1 (HEAD -> master)
Author: Rui Ueyama <ruiu@cs.stanford.edu>
Date:   Sat Aug 4 23:12:31 2018 +0000

    创建能编译单个整数的编译器

diff --git a/9cc.c b/9cc.c
new file mode 100644
index 0000000..e6e4599
--- /dev/null
+++ b/9cc.c
@@ -0,0 +1,16 @@
+#include <stdio.h>
+#include <stdlib.h>
+
+int main(int argc, char **argv) {
+  if (argc != 2) {
...
```

最后，将到目前为止创建的git仓库上传到GitHub。虽然没有必须上传的强制理由，但也没有不上传的理由，而且GitHub可以作为代码的备份发挥作用。要上传到GitHub，需先创建新仓库（本例中，用户rui314创建了名为9cc的仓库），然后通过以下命令将该仓库添加为远程仓库：

```bash
git remote add origin git@github.com:rui314/9cc.git
```

之后执行git push，本地仓库的内容就会被推送到GitHub。执行git push后，在浏览器中打开GitHub，确认自己的源代码已上传。

至此，第1步的编译器创建完成。这个步骤的编译器虽然简单到几乎不能称之为编译器，但它包含了编译器所需的所有要素。我们将在此基础上不断扩展功能，难以想象的是，它最终会成长为一个像样的C编译器。先好好感受一下完成第一步的成就感吧。

## 步骤2：创建能进行加减运算的编译器

在这个步骤中，我们要扩展上一步创建的编译器，使其能够接收不仅包含42这样的值，还包含2+11、5+20-4等包含加减运算的表达式。

像5+20-4这样的表达式，编译时可以直接计算出结果（这里是21）并嵌入到汇编代码中，但那样就不是编译器而是解释器了，所以需要输出在运行时执行加减运算的汇编代码。执行加法和减法的汇编指令是add和sub。add接收两个寄存器，将它们的内容相加，并把结果写入第一个参数的寄存器。sub与add类似，但执行减法。使用这些指令，5+20-4可以编译如下：

```asm
.intel_syntax noprefix
.globl main
main:
  mov rax, 5
  add rax, 20
  sub rax, 4
  ret
```

在上面的汇编代码中，用mov将5存入RAX，然后给RAX加20，再减4。执行ret时，RAX的值应该是5+20-4，即21。实际运行确认一下，将上面的内容保存到tmp.s文件，进行汇编并执行：

```bash
$ cc -o tmp tmp.s
$ ./tmp
$ echo $?
21
```

如上所示，正确显示了21。

那么，如何创建这个汇编文件呢？将包含加减运算的表达式视为一种“语言”，可以这样定义：

1. 开头有一个数字
2. 后面跟0个或多个“项”
3. 项是指“+后面跟数字”或“-后面跟数字”

将这个定义直接转化为C代码，得到如下程序：

```c
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char **argv) {
  if (argc != 2) {
    fprintf(stderr, "参数个数不正确\n");
    return 1;
  }

  char *p = argv[1];

  printf(".intel_syntax noprefix\n");
  printf(".globl main\n");
  printf("main:\n");
  printf("  mov rax, %ld\n", strtol(p, &p, 10));

  while (*p) {
    if (*p == '+') {
      p++;
      printf("  add rax, %ld\n", strtol(p, &p, 10));
      continue;
    }

    if (*p == '-') {
      p++;
      printf("  sub rax, %ld\n", strtol(p, &p, 10));
      continue;
    }

    fprintf(stderr, "意外的字符: '%c'\n", *p);
    return 1;
  }

  printf("  ret\n");
  return 0;
}
```

这段程序稍长，但前半部分和ret那一行与之前相同，中间增加了读取项的代码。由于现在不仅要读取单个数字，还需要知道读取了多少个字符，而atoi不返回读取的字符数，无法确定从哪里开始读取下一项，因此这里使用了C标准库的strtol函数。

strtol读取数值后，会更新第二个参数的指针，使其指向读取的最后一个字符的下一个字符。因此，读取一个数值后，如果下一个字符是+或-，p应该指向该字符。上面的程序利用这一点，在while循环中逐个读取项，每读取一项就输出一行汇编代码。

赶紧运行这个改造后的编译器吧。更新9cc.c文件后，只需执行make就能创建新的9cc文件。执行示例如下：

```bash
$ make
$ ./9cc '5+20-4'
.intel_syntax noprefix
.globl main
main:
  mov rax, 5
  add rax, 20
  sub rax, 4
  ret
```

看起来成功输出了汇编代码。为了测试这个新功能，在test.sh中添加如下一行测试：

```bash
assert 21 "5+20-4"
```

完成后，将这些变更提交到git。执行以下命令：

```bash
git add test.sh 9cc.c
git commit
```

执行git commit后会启动编辑器，输入“添加加法和减法”并保存，退出编辑器。使用git log -p命令确认提交是否符合预期，最后执行git push将提交推送到GitHub，这个步骤就完成了！

## 步骤3：引入词法分析器

上一步创建的编译器有一个缺点：如果输入中包含空白字符，就会出错。例如，像下面这样输入带有空格的5 - 3，在尝试读取+或-时会遇到空白字符，导致编译失败：

```bash
$ ./9cc '5 - 3' > tmp.s
意外的字符: ' '
```

解决这个问题的方法有多种。一个简单的方法是在读取+或-之前跳过空白字符。虽然这种方法没有特别的问题，但在这个步骤中，我们将用另一种方法解决：在读取表达式之前，先将输入分割为单词。

和日语、英语一样，算术表达式和编程语言也可以看作由单词序列构成。例如，5+20-4可以看作由5、+、20、-、4这5个单词构成。这种“单词”称为“令牌”（token）。令牌之间的空白字符只是为了分隔令牌，并非单词的组成部分。因此，将字符串分割为令牌序列时，去除空白字符是很自然的做法。将字符串分割为令牌序列的过程称为“词法分析”（tokenize）。

将字符串分割为令牌序列还有其他好处。分割时可以对每个令牌进行分类并赋予类型，例如+和-是运算符，而123这样的字符串表示数值。这样，在处理令牌序列时，需要考虑的事情就会减少。

对于目前支持加减运算的表达式的语法，令牌的类型有+、-和数值3种。此外，为了方便编译器实现，定义一个表示令牌序列结束的特殊类型（类似于字符串以'\0'结束）会使程序更简洁。我们将令牌用指针连接成链表，以处理任意长度的输入。

虽然代码稍长，但下面是引入词法分析器后改进的编译器版本：

```c
#include <ctype.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// 令牌的种类
typedef enum {
  TK_RESERVED, // 符号
  TK_NUM,      // 整数令牌
  TK_EOF,      // 表示输入结束的令牌
} TokenKind;

typedef struct Token Token;

// 令牌类型
struct Token {
  TokenKind kind; // 令牌的类型
  Token *next;    // 下一个输入令牌
  int val;        // kind为TK_NUM时的数值
  char *str;      // 令牌字符串
  int len;        // 令牌的长度
};

// 当前关注的令牌
Token *token;

// 报告错误的函数，接收与printf相同的参数
void error(char *fmt, ...) {
  va_list ap;
  va_start(ap, fmt);
  vfprintf(stderr, fmt, ap);
  fprintf(stderr, "\n");
  exit(1);
}

// 如果下一个令牌是预期的符号，则前进一个令牌并返回true，否则返回false
bool consume(char op) {
  if (token->kind != TK_RESERVED || token->str[0] != op)
    return false;
  token = token->next;
  return true;
}

// 如果下一个令牌是预期的符号，则前进一个令牌，否则报告错误
void expect(char op) {
  if (token->kind != TK_RESERVED || token->str[0] != op)
    error("不是'%c'", op);
  token = token->next;
}

// 如果下一个令牌是数值，则前进一个令牌并返回该数值，否则报告错误
int expect_number() {
  if (token->kind != TK_NUM)
    error("不是数字");
  int val = token->val;
  token = token->next;
  return val;
}

bool at_eof() {
  return token->kind == TK_EOF;
}

// 创建新令牌并连接到cur
Token *new_token(TokenKind kind, Token *cur, char *str, int len) {
  Token *tok = calloc(1, sizeof(Token));
  tok->kind = kind;
  tok->str = str;
  tok->len = len;
  cur->next = tok;
  return tok;
}

// 将输入字符串p进行词法分析并返回令牌序列
Token *tokenize(char *p) {
  Token head;
  head.next = NULL;
  Token *cur = &head;

  while (*p) {
    // 跳过空白字符
    if (isspace(*p)) {
      p++;
      continue;
    }

    if (*p == '+' || *p == '-') {
      cur = new_token(TK_RESERVED, cur, p, 1);
      p++;
      continue;
    }

    if (isdigit(*p)) {
      cur = new_token(TK_NUM, cur, p, 0);
      char *start = p;
      cur->val = strtol(p, &p, 10);
      cur->len = p - start;
      continue;
    }

    error("无法进行词法分析");
  }

  new_token(TK_EOF, cur, p, 0);
  return head.next;
}

int main(int argc, char **argv) {
  if (argc != 2) {
    error("参数个数不正确");
    return 1;
  }

  // 进行词法分析
  token = tokenize(argv[1]);

  // 输出汇编的前半部分
  printf(".intel_syntax noprefix\n");
  printf(".globl main\n");
  printf("main:\n");

  // 表达式开头必须是数字，检查并输出第一条mov指令
  printf("  mov rax, %d\n", expect_number());

  // 处理'+ <数字>'或'- <数字>'形式的令牌序列，输出汇编代码
  while (!at_eof()) {
    if (consume('+')) {
      printf("  add rax, %d\n", expect_number());
      continue;
    }

    expect('-');
    printf("  sub rax, %d\n", expect_number());
  }

  printf("  ret\n");
  return 0;
}
```

这段代码约150行，不算短，但没有太多技巧，从头读应该能理解。

解释一下代码中使用的编程技巧：

我们用全局变量token表示解析器读取的令牌序列。解析器通过遍历链表形式的token来读取输入。这种使用全局变量的编程风格可能看起来不够优雅，但实际上，像这样将输入令牌序列当作标准输入流来处理，往往能使解析器的代码更易读，因此这里采用了这种风格。

直接操作token的代码被分到了consume、expect等函数中，其他函数不直接操作token。

tokenize函数构建了链表。构建链表时，创建一个虚拟的head元素，然后往其后添加新元素，最后返回head->next，这样代码会更简单。虽然head元素占用的内存几乎是浪费的，但局部变量的分配成本几乎为零，不必特别在意。

calloc是与malloc类似的内存分配函数，与malloc不同的是，calloc会将分配的内存初始化为零。这里为了省去初始化元素的麻烦，使用了calloc。

改进后的版本应该能跳过空白字符了，在test.sh中添加如下一行测试：

```bash
assert 41 " 12 + 34 - 5 "
```

由于Unix进程的退出码是0到255之间的数字，编写测试时要确保表达式的结果在0到255范围内。

将测试文件添加到git仓库，这个步骤就完成了。

## 步骤4：改进错误消息

到目前为止创建的编译器，当输入存在语法错误时，只能知道有错误，但不清楚具体情况。在这个步骤中，我们来改进这一点，使其能显示如下直观的错误消息：

```bash
$ ./9cc "1+3++" > tmp.s
1+3++
     ^ 不是数字
$ ./9cc "1 + foo + 5" > tmp.s
1 + foo + 5
    ^ 无法进行词法分析
```

为了显示这样的错误消息，需要知道错误发生在输入的第几个字节。为此，我们将程序字符串整体保存到user_input变量中，并新定义一个接收指向输入字符串中间的指针的错误显示函数。代码如下：

```c
// 输入程序
char *user_input;

// 报告错误位置
void error_at(char *loc, char *fmt, ...) {
  va_list ap;
  va_start(ap, fmt);

  int pos = loc - user_input;
  fprintf(stderr, "%s\n", user_input);
  fprintf(stderr, "%*s", pos, " "); // 输出pos个空格
  fprintf(stderr, "^ ");
  vfprintf(stderr, fmt, ap);
  fprintf(stderr, "\n");
  exit(1);
}
```

error_at接收的指针指向输入字符串的中间位置。通过计算该指针与输入开头指针的差值，就能知道错误发生在输入的第几个字节，然后用^标记出该位置。

将argv[1]保存到user_input，把error("不是数字")之类的代码改为error_at(token->str, "不是数字")，这个步骤就完成了。

对于实用级别的编译器，应该为输入错误时的行为编写测试，但目前错误消息只是为了辅助调试，所以这个阶段可以不写测试。

> **注：源代码的格式**
>
> 就像日语中如果标点等书写规范错误太多，文章会难以阅读一样，源代码如果缩进不当或空白使用不一致，即使内容正确，也不能称为整洁的代码。在代码格式这类细节上，应机械地遵循一定规则，努力写出不分散注意力、易于阅读的代码。
>
> 多人开发时，需要协商确定代码格式，但本书是个人开发，大家可以从某种程度上较为宽松的格式中选择自己喜欢的。
>
> 近年来开发的语言中，有一些为了消除关于代码格式的无意义争论，提供了官方格式化工具。例如，Go语言有gofmt命令，可以将源代码格式化得整洁。gofmt没有选择格式风格的选项，只能格式化为唯一的“Go官方格式”。通过不提供选择，Go完全解决了代码格式的问题。
>
> C和C++有clang-format这样的格式化工具，但本书并不特别推荐使用。与其写出格式混乱的代码后再格式化，不如从一开始就注意写出风格一致的代码。

---
> **注：因缩进错误导致的安全漏洞**
>
> 曾因C语言代码的缩进错误，导致iOS和macOS出现严重的安全问题。有漏洞的代码如下：
>
> ```c
> if ((err = ReadyHash(&SSLHashSHA1, &hashCtx)) != 0)
>   goto fail;
> if ((err = SSLHashSHA1.update(&hashCtx, &clientRandom)) != 0)
>   goto fail;
> if ((err = SSLHashSHA1.update(&hashCtx, &serverRandom)) != 0)
>   goto fail;
> if ((err = SSLHashSHA1.update(&hashCtx, &signedParams)) != 0)
>   goto fail;
>   goto fail;
> if ((err = SSLHashSHA1.final(&hashCtx, &hashOut)) != 0)
>   goto fail;
> ```
>
> 大家能看出哪里有漏洞吗？这段代码乍一看很普通，但仔细看会发现，从下面数第二行的goto语句不在if语句内，变成了总是执行的goto语句。
>
> 不幸的是，这段代码位于验证TLS证书的函数中，结果导致大部分验证证书的代码被goto语句无条件跳过，使得iOS/macOS会将非法证书当作正确证书接受（允许HTTPS网站的伪装）。这个漏洞在2014年被发现并修复。由于多余的goto fail导致程序失败，这个漏洞被称为goto fail漏洞。

## 语法的描述方法与递归下降语法解析

接下来，我们希望为语言添加乘除法以及括号的优先级，也就是 `*`、`/`、`()`。但要实现这一点，存在一个重要的技术挑战：乘法和除法需要在表达式中优先计算。例如，`1+2*3` 必须被解释为 `1+(2*3)`，而不是 `(1+2)*3`。这种规定“哪个运算符先结合”的规则，称为“运算符的优先级”（operator precedence）。

那么，如何处理运算符的优先级呢？我们目前所制作的编译器，只是从开头读取令牌序列并输出汇编代码。如果直接扩展现有代码以添加 `*` 和 `/`，`1+2*3` 会被错误地编译为 `(1+2)*3`。

现有的编译器当然能够妥善处理运算符的优先级。编译器的语法解析能力非常强大，只要代码符合语法规则，无论多么复杂的代码都能被正确解析。有时，我们甚至会觉得编译器的这种行为仿佛具备了超越人类的智能。但实际上，计算机并不具备人类那样的文本理解能力，语法解析完全是通过某种机械机制实现的。具体而言，它是如何工作的呢？

在本章中，我们先暂停编码，来学习语法解析的技术。本章将按照以下顺序讲解：

1. 了解解析器输出的数据结构，先把握最终目标
2. 学习定义语法规则的方法
3. 基于语法规则的定义方法，学习编写解析器的技术

### 用树结构表示语法结构

在编程语言解析器的实现中，输入通常是扁平的令牌序列，而输出则是表示嵌套结构的树。本书所创建的编译器也遵循这一结构。

在 C 语言中，if、while 等语法元素可以嵌套，用树结构来表示这种嵌套关系是很自然的。

数学表达式中存在诸如“括号内的表达式优先计算”“乘除法优先于加减法”等结构。乍一看，这些结构似乎难以用树来表示，但实际上，使用树可以非常简洁地表示表达式的结构。例如，`1*(2+3)` 这个表达式可以用下图所示的树来表示：

```bash
    *
   / \
  1   +
     / \
    2   3
```

如果采用“从树的末端开始计算”的规则，上述树就表示“1 乘以 2 加 3 的结果”，即 `1*(2+3)` 的具体计算顺序通过树的形状本身得到了体现。

再举一个例子，下图的树表示 `7-3-3`：

```bash
    -
   / \
  -   3
 / \
7   3
```

在上述树中，“减法需从左到右计算”这一规则的应用结果，通过树的形状被明确表示出来。也就是说，这棵树表示 `(7-3)-3 = 1`，而不是 `7-(3-3) = 7`。如果是后者，对应的树会向右加深。

需要从左到右计算的运算符称为“左结合”运算符，需要从右到左计算的运算符称为“右结合”运算符。在 C 语言中，除了赋值运算符 `=` 之外，大多数运算符都是左结合的。

利用树结构，可以表示任意长度的表达式。下图的树表示 `1*2+3*4*5`：

```bash
      +
     / \
    *   *
   / \  / \
  1  2 3  *
         / \
        4   5
```

这种树被称为“语法树”（syntax tree）。特别地，为简洁起见，去除了括号等用于分组的冗余元素、更紧凑地表示语法结构的树，称为“抽象语法树”（Abstract Syntax Tree，AST）。上面的这些树都可以称为抽象语法树。

抽象语法树是编译器的内部表示，可根据实现需求灵活定义。不过，像加减乘除这样的算术运算符，都是对左右两个操作数进行运算，因此在任何编译器中，将它们表示为二叉树都是很自然的。另一方面，对于函数体中的表达式等只需依次执行、数量不固定的元素，用具有多个子元素的扁平树来表示会更自然。

语法解析的目标就是构建抽象语法树。编译器首先通过语法解析，将输入的令牌序列转换为抽象语法树，然后再将该语法树转换为汇编代码。

### 用生成规则定义语法

接下来，我们学习编程语言语法的描述方法。编程语言的大部分语法都是通过“生成规则”（production rule）来定义的。生成规则是一种递归定义语法的规则。

我们不妨对自然语言稍加思考。日语的语法存在嵌套结构，例如“花がきれいだ”这句话中的名词“花”，可以替换为名词短语“赤い花”；而“赤い”还可以进一步扩展为“少し赤い”。我们也可以将“少し赤い花がきれいだと私は思った”这样的句子嵌入到另一个句子中。

我们可以将这种语法定义为如下规则：“‘句子’由‘主语’和‘谓语’组成”“‘名词短语’由‘名词’或‘形容词’后接‘名词短语’组成”等。以“句子”为起点，按照这些规则进行扩展，就能生成无数符合该语法的正确句子。

反过来，对于已存在的句子，通过寻找与之匹配的扩展步骤，也能分析其结构。

这种想法原本是为自然语言提出的，但由于它与计算机处理的数据具有很高的兼容性，生成规则被广泛应用于计算机领域，其中就包括编程语言。

> **注：乔姆斯基的生成语法**
> 提出生成语法这一想法的是语言学家诺姆·乔姆斯基（Noam Chomsky）。他的思想对语言学和计算机科学产生了巨大影响。
> 根据乔姆斯基的假说，人类能够说话，是因为大脑中天生存在获取生成规则的专用回路。人类具有获取递归语言规则的能力，因此才能学会说话。他认为，其他动物没有语言获取能力，是因为它们的大脑中不存在这样的回路。乔姆斯基的主张自提出以来近 60 年，既未被证实也未被证伪，但至今仍被认为具有相当的说服力。

### 用 BNF 描述生成规则

作为一种简洁且易于理解的生成规则描述记法，有 BNF（巴科斯 - 诺尔形式）及其扩展形式 EBNF（扩展巴科斯 - 诺尔形式）。本书将使用 EBNF 来解释 C 语言的语法。本节先讲解 BNF，然后说明 EBNF 的扩展部分。

在 BNF 中，一条生成规则表示为 `A = α₁ α₂ …` 的形式，意思是符号 A 可以展开为 `α₁ α₂ …`。`α₁ α₂ …` 是 0 个或多个符号的序列，其中既包含不能再展开的符号，也包含可以展开（即出现在某个生成规则左边）的符号。

不能再展开的符号称为“终结符号”（terminal symbol），出现在某个生成规则左边且可以展开的符号称为“非终结符号”（nonterminal symbol）。用这种生成规则定义的语法通常称为“上下文无关文法”（context free grammar）。一个非终结符号可以匹配多个生成规则，例如如果有 `A = α₁` 和 `A = α₂` 两条规则，意思是 A 可以展开为 `α₁` 或者 `α₂`。

生成规则的右边可以是空的。在这种规则中，左边的符号会被展开为空字符串（即什么都没有）。但为了避免混淆，在这种情况下，通常会在右边写上 ε（epsilon）来表示空，本书也采用这一规则。

字符串用双引号括起来，如 `"foo"`，字符串总是终结符号。

以上是 BNF 的基本规则。在 EBNF 中，除了 BNF 的规则外，还可以使用以下符号来简洁地描述复杂规则：

| 写法 | 含义 |
| --- | --- |
| A* | A 重复 0 次或多次 |
| A? | A 或 ε |
| A \| B | A 或 B |
| ( ... ) | 分组 |

例如，`A = ("fizz" | "buzz")*` 表示 A 可以展开为“fizz”或“buzz”重复 0 次或多次的字符串，即：
`""`、`"fizz"`、`"buzz"`、`"fizzfizz"`、`"fizzbuzz"`、`"buzzfizz"`、`"buzzbuzz"`、`"fizzfizzfizz"`、`"fizzfizzbuzz"` 等等。

> **注：BNF 与 EBNF**
> 非扩展的普通 BNF 没有 `*`、`?`、`|`、`(...)` 这些简洁记法，但 BNF 和 EBNF 所能生成的句子是相同的。因为可以通过如下方式将 EBNF 转换为 BNF：
>
> | EBNF | 对应的 BNF |
> | --- | --- |
> | A = α* | A = α A 和 A = ε |
> | A = α? | A = α 和 A = ε |
> | A = α \| β | A = α 和 A = β |
> | A = α (β₁ β₂ …) γ | A = α B γ 和 B = β₁ β₂ … |
>
> 例如，使用 `A = αA` 和 `A = ε` 这两条生成规则，从 A 生成 `ααα` 的过程为：A → αA → ααA → αααA → ααα。
> 像 `*` 和 `?` 这样的记法只是简写，但简短的写法更易于理解，所以在可以使用简短记法时，通常会用它来简洁描述。

### 简单的生成规则

作为使用 EBNF 描述语法的例子，考虑以下生成规则：
`expr = num ("+" num | "-" num)*`

假设 num 在其他地方被定义为表示数值的符号。在这个语法中，expr 首先是一个 num，后面跟 0 个或多个“+ 和 num”或“- 和 num”。这条规则实际上表示了加减运算表达式的语法。

从 expr 出发进行扩展，可以生成任意的加减运算字符串，例如 1、10+5、42-30+2 等。我们来确认以下扩展结果：

- expr → num → "1"
- expr → num "+" num → "10" "+" "5"
- expr → num "-" num "+" num → "42" "-" "30" "+" "2"

除了用箭头按扩展顺序表示外，也可以用树结构来表示这些扩展过程。下面是上述表达式的语法树：

1 的语法树：

```bash
expr
|
num
|
"1"
```

10+5 的语法树：

```bash
   expr
  /  \
num   + num
|      |
"10"   "5"
```

42-30+2 的语法树：

```bash
       expr
      /   \
     /     \
    /       \
   /         \
num          + num
|            |
"42"         "2"
  \
   \
    - num
       |
      "30"
```

通过树结构，可以更清晰地看出每个非终结符号被扩展成了哪些符号。

像上图这样，包含输入中所有令牌、与语法完全一一对应的语法树，有时被称为“具体语法树”（concrete syntax tree）。这个术语常用于与抽象语法树进行对比。

需要注意的是，上述具体语法树中，并没有通过树的形状表示“加减运算从左到右计算”这一规则。在此处介绍的语法中，这种规则不会用 EBNF 表示，而是在语言规格说明书中以文字补充说明，如“加减运算从左到右计算”。解析器需要同时考虑 EBNF 和补充说明，读取表示表达式的令牌序列，构建能正确表示表达式求值顺序的抽象语法树。

因此，在上述语法中，EBNF 表示的具体语法树与解析器输出的抽象语法树的形状大致相同，但并不完全一致。虽然可以定义语法使抽象语法树和具体语法树的结构尽可能相同，但这样会导致语法变得冗余，难以确定解析器的编写方式。上述语法在形式化语法描述的严谨性和自然语言补充说明的易懂性之间取得了平衡，是一种易于处理的语法表示方法。

### 用生成规则表示运算符的优先级

生成规则是描述语法的强大工具，通过巧妙设计语法，还可以在生成规则中表示运算符的优先级。能体现优先级的语法如下：

```bash
expr = mul ("+" mul | "-" mul)*
mul  = num ("*" num | "/" num)*
```

在之前的规则中，expr 直接展开为 num，而这次，expr 通过 mul 间接展开为 num。mul 是表示乘除法的生成规则，进行加减运算的 expr 将 mul 作为一个组件来使用。在这个语法中，乘除法会优先结合的规则，自然地通过语法树的结构体现出来。我们具体看几个例子：

1*2+3 的语法树：

```bash
    expr
   /  \
  mul  + mul
 /  \    |
num * num num
|     |    |
"1"  "2"  "3"
```

1+2*3 的语法树：

```bash
    expr
   /  \
  mul  + mul
  |    /  \
num  num * num
|     |     |
"1"  "2"   "3"
```

1*2+3*4*5 的语法树：

```bash
        expr
       /   \
      /     \
     /       \
    /         \
   mul        + mul
  /  \       /   \
num * num   /     \
|     |     /       \
"1"  "2"  mul       * num
          /  \       |
         num * num  "5"
         |     |
        "3"   "4"
```

在上面的树结构中，乘法运算总是出现在比加法运算更靠近叶节点的位置。实际上，由于没有从 mul 回到 expr 的规则，无法形成加法运算在乘法运算之下的树结构。尽管如此，仅通过这样简单的规则，就能将优先级通过树结构很好地表示出来，这确实有点令人不可思议。请大家结合生成规则和语法树，确认语法树的正确性。

## 包含递归的生成规则

生成文法中，编写递归文法是很常见的。下面是为四则运算添加了表示优先级的括号后的文法生成规则：

```bash
expr    = mul ("+" mul | "-" mul)*
mul     = primary ("*" primary | "/" primary)*
primary = num | "(" expr ")"
```

与之前的文法相比，原本允许出现num的地方，现在变成了允许出现primary，即num或者“( expr )”。也就是说，在这个新文法中，用括号括起来的表达式和单个数字被视为具有相同“结合强度”的元素。我们来看一个例子：

下面是1*(2+3)的语法树：

```bash
    expr
    |
    mul
   /  \
primary primary
 |       |
num      ( expr )
 |          |
"1"        mul
           /  \
      primary  primary
       |         |
      num        num
       |         |
      "2"       "3"
```

对比两个树可以发现，只是mul右边的primary展开结果不同。展开后最终出现的primary，既可以是单个数字，也可以是用括号括起来的任意表达式，这一规则通过树结构清晰地体现出来。仅仅通过这样简单的生成规则就能处理括号的优先级，实在是令人赞叹。

### 递归下降语法解析

有了C语言的生成规则，我们可以通过不断扩展规则，机械地生成任何符合该规则的正确C程序。但在9cc编译器中，我们要做的恰恰相反：对于给定的C程序字符串，找到能生成该字符串的扩展步骤，也就是确定与输入字符串对应的语法树结构。

实际上，对于某些生成规则，只要给定规则，就可以机械地编写代码来求解与生成的句子匹配的语法树。这里要介绍的“递归下降语法解析法”就是其中一种技术。

我们以四则运算的文法为例来讲解。再次列出四则运算的文法：

```bash
expr    = mul ("+" mul | "-" mul)*
mul     = primary ("*" primary | "/" primary)*
primary = num | "(" expr ")"
```

递归下降语法解析法编写解析器的基本策略是：将每个非终结符号直接对应为一个函数。因此，解析器会包含expr、mul、primary三个函数，分别用于解析对应的语法结构。

具体到代码层面，解析器的输入是令牌序列。由于我们希望解析器返回抽象语法树，需要先定义抽象语法树节点的类型。节点类型定义如下：

```c
// 抽象语法树节点的种类
typedef enum {
    ND_ADD, // +
    ND_SUB, // -
    ND_MUL, // *
    ND_DIV, // /
    ND_NUM, // 整数
} NodeKind;

typedef struct Node Node;

// 抽象语法树节点的类型
struct Node {
    NodeKind kind; // 节点的类型
    Node *lhs;     // 左操作数
    Node *rhs;     // 右操作数
    int val;       // 当kind为ND_NUM时使用
};
```

其中，lhs和rhs分别是left-hand side和right-hand side的缩写，即左操作数和右操作数。

我们还需要定义创建新节点的函数。由于该文法中的四则运算包含接受左右两个操作数的二元运算符和数值两种类型，因此需要准备两个对应的函数：

```c
Node *new_node(NodeKind kind, Node *lhs, Node *rhs) {
    Node *node = calloc(1, sizeof(Node));
    node->kind = kind;
    node->lhs = lhs;
    node->rhs = rhs;
    return node;
}

Node *new_node_num(int val) {
    Node *node = calloc(1, sizeof(Node));
    node->kind = ND_NUM;
    node->val = val;
    return node;
}
```

接下来，我们使用这些函数和数据类型来编写解析器。+和-是左结合运算符，解析左结合运算符的函数通常按以下模式编写：

```c
Node *expr() {
    Node *node = mul();

    for (;;) {
        if (consume('+'))
            node = new_node(ND_ADD, node, mul());
        else if (consume('-'))
            node = new_node(ND_SUB, node, mul());
        else
            return node;
    }
}
```

这里的consume是之前步骤中定义的函数，当输入流中的下一个令牌与参数匹配时，会读取该令牌并返回true。

仔细看expr函数，会发现它直接对应了`expr = mul ("+" mul | "-" mul)*`这条生成规则。上述expr函数返回的抽象语法树中，运算符是左结合的，即返回的节点左侧的分支更深。

expr函数调用的mul函数也按同样的模式定义。由于*和/也是左结合运算符，因此可以用相同的模式描述：

```c
Node *mul() {
    Node *node = primary();

    for (;;) {
        if (consume('*'))
            node = new_node(ND_MUL, node, primary());
        else if (consume('/'))
            node = new_node(ND_DIV, node, primary());
        else
            return node;
    }
}
```

上述代码的函数调用关系与`mul = primary ("*" primary | "/" primary)*`这条规则完全对应。

最后定义primary函数。由于primary不是左结合运算符，其代码结构与上述函数不同，但通过将`primary = "(" expr ")" | num`这条生成规则直接对应为函数调用，可以写出如下的primary函数：

```c
Node *primary() {
    // 如果下一个令牌是"("，则应该是"(" expr ")"的形式
    if (consume('(')) {
        Node *node = expr();
        expect(')');
        return node;
    }

    // 否则应该是数值
    return new_node_num(expect_number());
}
```

现在，所有函数都已定义完毕，但可能还是会疑惑这些函数是否真的能解析令牌序列。虽然乍看之下不太直观，但使用这些函数确实可以正确解析令牌序列。我们以1+2*3这个表达式为例来分析：

解析开始时，首先调用expr函数。由于表达式整体是一个expr（实际上确实如此），我们从读取输入开始。此时，函数调用流程为expr→mul→primary，读取到1这个令牌，expr函数获得一个表示1的语法树节点。

接着，expr函数中的consume('+')判断为真，读取+令牌，并再次调用mul函数。此时输入中剩余的部分是2*3。

与之前一样，mul函数调用primary读取2这个令牌，但这次mul函数不会立即返回。由于mul函数中的consume('*')判断为真，会再次调用primary读取3这个令牌。最终，mul函数返回一个表示2*3的语法树节点。

回到expr函数，将表示1的语法树节点与表示2*3的语法树节点组合，构建出表示1+2*3的语法树，并将其作为expr函数的返回值。这样就正确解析了1+2*3。

函数调用关系以及每个函数读取的令牌如下图所示。图中，最上层的expr对应整个1+2*3的解析，而它下面的两个mul分别对应1和2*3的解析。

```bash
          expr
         /    \
        /      \
       /        \
      /          \
     mul        mul
     |          /  \
     |         /    \
     |        /      \
primary    primary  primary
     |        |        |
     1        2        3
     +        *
```

1+2*3的解析过程中的函数调用关系

再来看一个更复杂的例子。下图展示了解析1*2+(3+4)时的函数调用关系：

```bash
              expr
             /    \
            /      \
           /        \
          /          \
         mul        mul
        /  \         |
       /    \        |
      /      \       |
primary    primary  expr
   |          |       |
   1          2      mul
                    /  \
                   /    \
                  /      \
             primary    primary
                |          |
                3          4
                +
```

1*2+(3+4)的解析过程中的函数调用关系

对于不熟悉递归的程序员来说，上述递归函数可能难以理解。说实话，即使是习惯了递归的笔者，也觉得这样的代码能正常工作有点像魔法。递归代码即使理解了原理，有时还是会让人觉得不可思议，但或许这就是递归的特性吧。建议大家多在脑海中模拟代码的执行过程，确认代码确实能正常工作。

像这样将每个生成规则对应为一个函数的语法解析方法，称为“递归下降语法解析”。上面的解析器通过仅预读一个令牌，来决定调用哪个函数或返回，这种仅预读一个令牌的递归下降解析器称为LL(1)解析器。能够用LL(1)解析器解析的文法称为LL(1)文法。

## 栈机（Stack Machine）

前一章讲解了将令牌序列转换为抽象语法树的算法。通过选择考虑运算符优先级的语法，我们能够构建出抽象语法树，其中 `*` 和 `/` 总是出现在树的更深层，优先于 `+` 和 `-` 进行计算。但问题是，如何将这个树转换为汇编代码呢？本章将介绍具体的方法。

首先，我们来思考为什么加法和减法的实现方式不能直接用于处理包含乘除法的表达式。在支持加减运算的编译器中，我们使用 `RAX` 寄存器存储结果，并在其中直接进行加法和减法操作。也就是说，编译后的程序只能保留一个中间计算结果。

然而，当表达式中包含乘除法时，中间计算结果可能不止一个。例如，计算 `2*3+4*5` 时，为了进行加法运算，需要先计算出 `2*3` 和 `4*5` 这两个结果。因此，这种情况下需要同时保存两个中间结果，否则无法完成整个表达式的计算。

“栈机”（Stack Machine）正是解决这类问题的有效工具。本章我们将暂时放下解析器构建的内容，先来学习栈机的相关知识。

### 栈机的概念

栈机是一种拥有栈作为数据存储区域的计算机。因此，栈机的基本操作是“将数据压入栈”（push）和“从栈中弹出数据”（pop）。压栈操作会将新元素添加到栈的顶部；出栈操作则会移除栈顶部的元素。

栈机中的运算指令作用于栈顶的元素。例如，栈机的 `ADD` 指令会从栈顶弹出两个元素，将它们相加，然后把结果压回栈中（为了与 x86-64 指令区分开，虚拟栈机的指令将全部使用大写字母表示）。同理，`SUB`、`MUL`、`DIV` 指令也会从栈顶弹出两个元素，分别执行减法、乘法、除法运算，并将结果压回栈中。

`PUSH` 指令用于将指定的元素压入栈顶。虽然这里暂不使用，但还可以定义 `POP` 指令，用于从栈顶弹出一个元素并丢弃它。

下面我们以计算 `2*3+4*5` 为例，看看如何使用栈机的指令来完成这个计算。按照上述指令定义，相应的栈机代码如下：

```bash
// 计算 2*3
PUSH 2
PUSH 3
MUL

// 计算 4*5
PUSH 4
PUSH 5
MUL

// 计算 2*3 + 4*5
ADD
```

我们来详细分析这段代码的执行过程。假设栈初始状态为包含一些无关值（用“……”表示），栈的增长方向为从上到下。

前两条 `PUSH` 指令将 2 和 3 压入栈，执行 `MUL` 指令时，栈的状态如下：

| 栈内容 |
|--------|
| ……     |
| 2      |
| 3      |

`MUL` 指令会弹出栈顶的两个值（3 和 2），计算它们的乘积（6），并将结果压回栈。执行后栈的状态变为：

| 栈内容 |
|--------|
| ……     |
| 6      |

接着，两条 `PUSH` 指令将 4 和 5 压入栈，执行第二个 `MUL` 指令前，栈的状态是：

| 栈内容 |
|--------|
| ……     |
| 6      |
| 4      |
| 5      |

执行 `MUL` 指令，弹出 5 和 4 并计算乘积（20），压回栈后：

| 栈内容 |
|--------|
| ……     |
| 6      |
| 20     |

最后执行 `ADD` 指令，弹出 20 和 6 并计算和（26），压回栈，最终栈的状态为：

| 栈内容 |
|--------|
| ……     |
| 26     |

如果将栈顶的值作为计算结果，那么 26 就是 `2*3+4*5` 的正确结果，说明使用栈机能够正确完成复杂表达式的计算。

栈机的优势在于，无论表达式多么复杂，只要每个子表达式的计算结果最终都能以一个元素的形式留在栈顶，就可以按照上述方法正确计算出整个表达式的结果。

> **注：CISC 与 RISC**
>
> x86-64 是从 1978 年推出的 8086 逐步发展而来的指令集，是典型的“CISC”（复杂指令集计算机）处理器。CISC 处理器的特点包括：机器语言运算不仅可以操作寄存器，还能直接操作内存地址；机器语言指令的长度是可变的；提供了许多对汇编程序员来说很方便的复杂操作指令等。
>
> 与 CISC 相对，“RISC”（精简指令集计算机）在 20 世纪 80 年代被发明出来。RISC 处理器的特点有：运算只能在寄存器之间进行，对内存的操作仅通过加载（load）和存储（store）指令实现；所有机器语言指令的长度相同；不提供复杂的复合指令，只包含编译器容易生成的简单指令等。
>
> x86-64 是为数不多仍在广泛使用的 CISC 指令集之一，除此之外的主流处理器几乎都基于 RISC。例如，ARM、PowerPC、SPARC、MIPS、RISC-V（开源 RISC）等都是 RISC 处理器。
>
> RISC 没有 x86-64 中那种寄存器与内存之间直接进行运算的指令，也没有段寄存器，特定的整数寄存器也不会被特定指令赋予特殊用途。从现代的角度来看，x86-64 的指令集设计显得有些陈旧。
>
> 由于其简单的设计，RISC 处理器更容易实现高速化，并迅速在处理器行业占据了主导地位。那么 x86-64 为何能存活下来呢？这得益于市场对能够运行现有软件资产的高速 x86 处理器的巨大需求，以及 Intel 和 Intel 兼容芯片制造商为满足这一需求所进行的技术革新。Intel 通过硬件将 x86 指令转换为内部的一种 RISC 指令，使得 x86 处理器能够应用与 RISC 相同的高速化技术。

### 编译到栈机

本节将介绍如何把抽象语法树转换为栈机的代码。掌握了这一方法，我们就能解析包含四则运算的表达式，构建抽象语法树，再将其编译为基于 x86-64 指令的栈机代码并执行。也就是说，我们将能够实现一个支持四则运算的编译器。

如前所述，栈机的核心思想是：计算子表达式时，无论其具体形式如何，最终都会在栈顶留下一个值作为结果。例如，考虑下面这样的树：

```bash
    +
   / \
  A   B
```

其中 A 和 B 是表示子表达式的抽象节点，实际可以是任何类型的节点。将这个树编译为栈机代码的步骤如下：

1. 编译左子树 A，使其计算结果留在栈顶。
2. 编译右子树 B，使其计算结果留在栈顶。
3. 输出一条指令，弹出栈顶的两个值，进行加法运算，并将结果压回栈。

执行完步骤 1 后，栈顶是 A 的计算结果；执行完步骤 2 后，栈顶是 B 的计算结果，A 的结果位于其下方；步骤 3 执行加法运算后，栈顶就是 A + B 的结果。

这种递归的思考方式虽然对不熟悉递归的读者来说可能有些难以理解，但却是处理树这种自相似数据结构的常用且有效的方法。

我们结合具体例子来进一步说明。例如，对于如下抽象语法树：

```bash
    +
   / \
  2   *
     / \
    3   4
```

代码生成函数接收树的根节点（加法节点）作为参数。

按照上述步骤，首先编译左子树（数值 2），生成 `PUSH 2` 指令，栈顶为 2。

接着编译右子树（乘法节点）。对于乘法节点，同样先编译其左子树（数值 3），生成 `PUSH 3` 指令；再编译其右子树（数值 4），生成 `PUSH 4` 指令；然后生成 `MUL` 指令，此时栈顶是 3*4 的结果 12。

最后，针对根节点的加法运算，生成 `ADD` 指令，弹出栈顶的 12 和 2，计算得到 14 并压回栈。最终生成的汇编代码如下：

```bash
PUSH 2
PUSH 3
PUSH 4
MUL
ADD
```

通过这种方法，我们能够将抽象语法树机械地转换为栈机的汇编代码。

### x86-64 中栈机的实现方法

前面讨论的是虚拟栈机的工作原理，而实际的 x86-64 架构是寄存器机，并非栈机。x86-64 的运算通常定义在两个寄存器之间，而非直接作用于栈顶的两个值。因此，要在 x86-64 上使用栈机的技术，需要通过寄存器机来模拟栈机的行为。

用寄存器机模拟栈机的方法相对简单，只需将栈机的单条指令用多条寄存器机指令来实现。

首先，我们需要一个寄存器来指向栈的顶部元素，这个寄存器被称为“栈指针”（stack pointer）。如果要从栈顶弹出两个值，只需通过栈指针获取这两个元素，然后将栈指针调整到弹出元素后的位置。同样，压栈时，调整栈指针的位置，再将值写入相应的内存区域。

x86-64 架构中的 `RSP` 寄存器就是专门设计用作栈指针的。x86-64 的 `push` 和 `pop` 指令会隐式地使用 `RSP` 作为栈指针，在操作栈顶元素的同时自动调整 `RSP` 的值。因此，在 x86-64 上模拟栈机时，使用 `RSP` 作为栈指针是很自然的选择。

下面我们以计算 `1+2` 为例，看看如何用 x86-64 的汇编指令来模拟栈机的操作：

```asm
// 将左操作数和右操作数压入栈
push 1
push 2

// 从栈中弹出值到 RAX 和 RDI 寄存器，然后进行加法运算
pop rdi    ; 弹出 2 到 RDI
pop rax    ; 弹出 1 到 RAX
add rax, rdi  ; 计算 1 + 2，结果存入 RAX

// 将结果压回栈
push rax
```

x86-64 没有直接“对栈顶的两个值进行加法运算”的指令，所以需要先将栈顶的两个值弹出到寄存器中进行运算，再将结果压回栈。上述代码就是按照这个思路实现的加法操作。

同样地，我们可以用 x86-64 指令实现 `2*3+4*5` 的计算：

```asm
; 计算 2*3 并将结果压入栈
push 2
push 3
pop rdi
pop rax
imul rax, rdi  ; 乘法指令，结果存入 RAX
push rax

; 计算 4*5 并将结果压入栈
push 4
push 5
pop rdi
pop rax
imul rax, rdi
push rax

; 计算栈顶两个值的和（即 2*3 + 4*5）
pop rdi
pop rax
add rax, rdi
push rax
```

可以看到，使用 x86-64 的栈操作指令，我们能够写出与栈机逻辑非常相似的代码。

下面的 `gen` 函数就是按照这种思路，用 C 语言实现的代码生成器：

```c
void gen(Node *node) {
    if (node->kind == ND_NUM) {
        printf(" push %d\n", node->val);
        return;
    }

    gen(node->lhs);
    gen(node->rhs);

    printf(" pop rdi\n");
    printf(" pop rax\n");

    switch (node->kind) {
        case ND_ADD:
            printf(" add rax, rdi\n");
            break;
        case ND_SUB:
            printf(" sub rax, rdi\n");
            break;
        case ND_MUL:
            printf(" imul rax, rdi\n");
            break;
        case ND_DIV:
            printf(" cqo\n");
            printf(" idiv rdi\n");
            break;
    }

    printf(" push rax\n");
}
```

需要说明的是，上述代码中除法指令 `idiv` 的使用涉及一些特殊的细节。在 x86-64 中，`idiv` 是用于有符号除法的指令，其操作方式与其他运算指令有所不同。它并非接收两个寄存器作为参数，而是默认将 `RDX:RAX` 视为一个 128 位的整数（`RDX` 为高 64 位，`RAX` 为低 64 位），然后用这个 128 位整数除以作为参数的寄存器中的 64 位值，商存入 `RAX`，余数存入 `RDX`。

`cqo` 指令的作用是将 `RAX` 中的 64 位值符号扩展到 `RDX:RAX`，使其成为一个 128 位的整数。在进行除法运算前使用 `cqo` 指令，是为了正确处理有符号数的除法。

至此，我们完成了栈机相关知识的介绍。通过学习，我们掌握了如何将复杂的表达式通过栈机的思想在 x86-64 架构上实现编译。接下来，让我们回到编译器的开发工作中！

> **注：优化编译器**
>
> 读者可能会觉得本章中示例的 x86-64 汇编代码效率很低。例如，将数值压入栈后又立即弹出到寄存器的操作，其实可以直接用 `mov` 指令将数值放入寄存器，一步就能完成。有些读者可能会想对这些汇编代码进行优化，去除冗余操作。但请不要急于这样做，在编译器开发的初期阶段，优先保证实现的简单性，输出冗余代码是合理且可取的。
>
> 我们可以在后续为 9cc 编译器添加优化阶段。对生成的汇编代码进行扫描，将特定模式的指令序列替换为更高效的指令序列并不困难。例如，“push 后立即 pop”的指令序列可以替换为 `mov` 指令；连续多次向同一个寄存器添加立即数的 `add` 指令，可以合并为一次添加总和的 `add` 指令等。通过这些规则，可以在不改变代码语义的前提下，将冗余代码转换为更高效的代码。
>
> 如果将代码生成和优化混合在一起，会使编译器变得复杂。一开始就编写复杂的代码，后续再添加优化阶段会更加困难。正如 Donald Knuth 所说：“过早的优化是一切邪恶的根源”。在开发我们的编译器时，请只考虑实现的简单性。输出中存在的明显冗余可以在后续阶段处理，不必担心。

## 步骤5：创建一种支持四则运算的语言

在本章中，我们将对前几章开发的编译器进行修改，使其能够处理包含四则运算以及括号优先级的表达式。所需的技术已经全部掌握，因此只需编写少量新代码即可。请修改编译器的`main`函数，使其使用新创建的解析器和代码生成器。修改后的代码大致如下所示：

```c
int main(int argc, char **argv) {
  if (argc != 2) {
    error("引数の個数が正しくありません");
    return 1;
  }

  // 进行词法分析和语法分析
  user_input = argv[1];
  token = tokenize(user_input);
  Node *node = expr();

  // 输出汇编代码的前半部分
  printf(".intel_syntax noprefix\n");
  printf(".globl main\n");
  printf("main:\n");

  // 遍历抽象语法树并生成代码
  gen(node);

  // 表达式的计算结果应该留在栈顶
  // 将其加载到RAX作为函数的返回值
  printf(" pop rax\n");
  printf(" ret\n");
  return 0;
}
```

到目前为止，编译器应该已经能够正确编译包含加减乘除和括号优先级的表达式了。我们来添加一些测试用例：

```bash
assert 47 '5+6*7'
assert 15 '5*(9-6)'
assert 4 '(3+5)/2'
```

需要说明的是，为了便于讲解，前面的内容似乎是一次性实现了`*`、`/`和`()`的功能，但在实际开发中，最好避免一次性实现多个功能。我们原本已经实现了加减运算功能，所以首先应该在不破坏该功能的前提下，引入抽象语法树及其代码生成器，此时不需要添加新的测试用例。之后，再逐步实现`*`、`/`和`()`的功能，并为每个功能添加相应的测试用例。

### 参考实现5

```c
#include <ctype.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

//
// Tokenizer
//

typedef enum {
  TK_RESERVED, // Keywords or punctuators
  TK_NUM,      // Integer literals
  TK_EOF,      // End-of-file markers
} TokenKind;

// Token type
typedef struct Token Token;
struct Token {
  TokenKind kind; // Token kind
  Token *next;    // Next token
  int val;        // If kind is TK_NUM, its value
  char *str;      // Token string
};

// Input program
char *user_input;

// Current token
Token *token;

// Reports an error and exit.
void error(char *fmt, ...) {
  va_list ap;
  va_start(ap, fmt);
  vfprintf(stderr, fmt, ap);
  fprintf(stderr, "\n");
  exit(1);
}

// Reports an error location and exit.
void error_at(char *loc, char *fmt, ...) {
  va_list ap;
  va_start(ap, fmt);

  int pos = loc - user_input;
  fprintf(stderr, "%s\n", user_input);
  fprintf(stderr, "%*s", pos, ""); // print pos spaces.
  fprintf(stderr, "^ ");
  vfprintf(stderr, fmt, ap);
  fprintf(stderr, "\n");
  exit(1);
}

// Consumes the current token if it matches `op`.
bool consume(char op) {
  if (token->kind != TK_RESERVED || token->str[0] != op)
    return false;
  token = token->next;
  return true;
}

// Ensure that the current token is `op`.
void expect(char op) {
  if (token->kind != TK_RESERVED || token->str[0] != op)
    error_at(token->str, "expected '%c'", op);
  token = token->next;
}

// Ensure that the current token is TK_NUM.
int expect_number() {
  if (token->kind != TK_NUM)
    error_at(token->str, "expected a number");
  int val = token->val;
  token = token->next;
  return val;
}

bool at_eof() {
  return token->kind == TK_EOF;
}

// Create a new token and add it as the next token of `cur`.
Token *new_token(TokenKind kind, Token *cur, char *str) {
  Token *tok = calloc(1, sizeof(Token));
  tok->kind = kind;
  tok->str = str;
  cur->next = tok;
  return tok;
}

// Tokenize `user_input` and returns new tokens.
Token *tokenize() {
  char *p = user_input;
  Token head;
  head.next = NULL;
  Token *cur = &head;

  while (*p) {
    // Skip whitespace characters.
    if (isspace(*p)) {
      p++;
      continue;
    }

    // Punctuator
    if (strchr("+-*/()", *p)) {
      cur = new_token(TK_RESERVED, cur, p++);
      continue;
    }

    // Integer literal
    if (isdigit(*p)) {
      cur = new_token(TK_NUM, cur, p);
      cur->val = strtol(p, &p, 10);
      continue;
    }

    error_at(p, "invalid token");
  }

  new_token(TK_EOF, cur, p);
  return head.next;
}

//
// Parser
//

typedef enum {
  ND_ADD, // +
  ND_SUB, // -
  ND_MUL, // *
  ND_DIV, // /
  ND_NUM, // Integer
} NodeKind;

// AST node type
typedef struct Node Node;
struct Node {
  NodeKind kind; // Node kind
  Node *lhs;     // Left-hand side
  Node *rhs;     // Right-hand side
  int val;       // Used if kind == ND_NUM
};

Node *new_node(NodeKind kind) {
  Node *node = calloc(1, sizeof(Node));
  node->kind = kind;
  return node;
}

Node *new_binary(NodeKind kind, Node *lhs, Node *rhs) {
  Node *node = new_node(kind);
  node->lhs = lhs;
  node->rhs = rhs;
  return node;
}

Node *new_num(int val) {
  Node *node = new_node(ND_NUM);
  node->val = val;
  return node;
}

Node *expr();
Node *mul();
Node *primary();

// expr = mul ("+" mul | "-" mul)*
Node *expr() {
  Node *node = mul();

  for (;;) {
    if (consume('+'))
      node = new_binary(ND_ADD, node, mul());
    else if (consume('-'))
      node = new_binary(ND_SUB, node, mul());
    else
      return node;
  }
}

// mul = primary ("*" primary | "/" primary)*
Node *mul() {
  Node *node = primary();

  for (;;) {
    if (consume('*'))
      node = new_binary(ND_MUL, node, primary());
    else if (consume('/'))
      node = new_binary(ND_DIV, node, primary());
    else
      return node;
  }
}

// primary = "(" expr ")" | num
Node *primary() {
  if (consume('(')) {
    Node *node = expr();
    expect(')');
    return node;
  }

  return new_num(expect_number());
}

//
// Code generator
//

void gen(Node *node) {
  if (node->kind == ND_NUM) {
    printf("  push %d\n", node->val);
    return;
  }

  gen(node->lhs);
  gen(node->rhs);

  printf("  pop rdi\n");
  printf("  pop rax\n");

  switch (node->kind) {
  case ND_ADD:
    printf("  add rax, rdi\n");
    break;
  case ND_SUB:
    printf("  sub rax, rdi\n");
    break;
  case ND_MUL:
    printf("  imul rax, rdi\n");
    break;
  case ND_DIV:
    printf("  cqo\n");
    printf("  idiv rdi\n");
    break;
  }

  printf("  push rax\n");
}

int main(int argc, char **argv) {
  if (argc != 2)
    error("%s: invalid number of arguments", argv[0]);

  // Tokenize and parse.
  user_input = argv[1];
  token = tokenize();
  Node *node = expr();

  // Print out the first half of assembly.
  printf(".intel_syntax noprefix\n");
  printf(".global main\n");
  printf("main:\n");

  // Traverse the AST to emit assembly.
  gen(node);

  // A result must be at the top of the stack, so pop it
  // to RAX to make it a program exit code.
  printf("  pop rax\n");
  printf("  ret\n");
  return 0;
}
```

> **注：9cc中的内存管理**
>
> 读到这里，读者可能会疑惑这个编译器是如何进行内存管理的。到目前为止的代码中，我们使用了`calloc`（`malloc`的一种变体）来分配内存，却没有调用`free`来释放内存，这意味着分配的内存从未被释放。这难道不是一种偷工减料的做法吗？
>
> 实际上，这种“不进行内存管理”的内存管理策略是作者经过深思熟虑后有意选择的设计。这种设计的优点是，由于不释放内存，我们可以像使用带有垃圾回收机制的语言一样编写代码。这不仅省去了编写内存管理代码的麻烦，还从根本上避免了与手动内存管理相关的各种难以捉摸的bug。
>
> 另一方面，在普通PC等计算机上运行时，不调用`free`所带来的问题实际上并不严重。编译器是一种短命的程序，它只需读取一个C文件并输出汇编代码即可。程序结束时，操作系统会自动释放所有已分配的内存。因此，真正需要关注的只是总共分配了多少内存。根据作者的实际测试，即使编译相当大的C文件，内存使用量也仅为100MiB左右。所以，不调用`free`是一种切实可行的策略。例如，D语言的编译器DMD也采用了同样的思路，只进行`malloc`而不执行`free`操作。

## 步骤6：单目加和单目减

减法运算符`-`不仅可以像`5-3`这样用在两个操作数之间，还可以像`-3`这样用在单个操作数前面。同理，加法运算符`+`也可以省略左操作数，写成`+3`的形式。这种只作用于一个操作数的运算符称为“单目运算符”（unary operator）。与之相对，作用于两个操作数的运算符则称为“双目运算符”（binary operator）。

C语言中，除了`+`和`-`，还有用于获取指针的`&`、用于解引用指针的`*`等单目运算符，但在本步骤中，我们只实现`+`和`-`。

单目`+`和单目`-`与双目`+`和`-`使用相同的符号，但它们的定义不同。双目`-`定义为用左操作数减去右操作数，而单目`-`根本没有左操作数，因此不能直接沿用双目`-`的定义。在C语言中，单目`-`被定义为对右操作数取相反数的运算；单目`+`则是直接返回右操作数的运算符，它虽然没有实际的运算意义，但由于单目`-`的存在而被顺带引入。

我们可以将`+`和`-`看作是名称相同但定义不同的运算符，它们是单目还是双目取决于所处的语境。包含单目`+`和`-`的新文法如下：

```bash
expr = mul ("+" mul | "-" mul)*
mul = unary ("*" unary | "/" unary)*
unary = ("+" | "-")? primary
primary = num | "(" expr ")"
```

在上述新文法中，增加了一个名为`unary`的非终结符，并且`mul`不再使用`primary`，而是使用`unary`。EBNF中，`X?`表示可选元素，即`X`可以出现0次或1次。`unary = ("+" | "-")? primary`这条规则表示，`unary`这个非终结符可以有一个`+`或`-`，也可以没有，其后必须跟一个`primary`。

请确认`-3`、`-(3+5)`、`-3*+5`等表达式是否符合这一新文法。下面是`-3*+5`的语法树：

```bash
expr
└── mul
    ├── unary
    │   ├── "-"
    │   └── primary
    │       └── num (3)
    └── unary
        ├── "+"
        └── primary
            └── num (5)
```

我们来修改解析器以遵循这一新文法。按照惯例，只需将文法直接映射为函数调用即可完成解析器的修改。用于解析`unary`的函数如下：

```c
Node *unary() {
  if (consume('+'))
    return primary();
  if (consume('-'))
    return new_node(ND_SUB, new_node_num(0), primary());
  return primary();
}
```

这里在解析阶段就将`+x`替换为`x`，将`-x`替换为`0-x`，因此不需要修改代码生成器。

添加几个测试用例，与添加单目`+`/`-`的代码一起进行检查，本步骤就完成了。编写测试用例时，要确保测试结果在0到255的范围内。可以使用`-10+20`这样的表达式，它使用了单目`-`，且整体结果为正数。

### 参考实现6

```c
#include <ctype.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

//
// Tokenizer
//

typedef enum {
  TK_RESERVED, // Keywords or punctuators
  TK_NUM,      // Integer literals
  TK_EOF,      // End-of-file markers
} TokenKind;

// Token type
typedef struct Token Token;
struct Token {
  TokenKind kind; // Token kind
  Token *next;    // Next token
  int val;        // If kind is TK_NUM, its value
  char *str;      // Token string
};

// Input program
char *user_input;

// Current token
Token *token;

// Reports an error and exit.
void error(char *fmt, ...) {
  va_list ap;
  va_start(ap, fmt);
  vfprintf(stderr, fmt, ap);
  fprintf(stderr, "\n");
  exit(1);
}

// Reports an error location and exit.
void error_at(char *loc, char *fmt, ...) {
  va_list ap;
  va_start(ap, fmt);

  int pos = loc - user_input;
  fprintf(stderr, "%s\n", user_input);
  fprintf(stderr, "%*s", pos, ""); // print pos spaces.
  fprintf(stderr, "^ ");
  vfprintf(stderr, fmt, ap);
  fprintf(stderr, "\n");
  exit(1);
}

// Consumes the current token if it matches `op`.
bool consume(char op) {
  if (token->kind != TK_RESERVED || token->str[0] != op)
    return false;
  token = token->next;
  return true;
}

// Ensure that the current token is `op`.
void expect(char op) {
  if (token->kind != TK_RESERVED || token->str[0] != op)
    error_at(token->str, "expected '%c'", op);
  token = token->next;
}

// Ensure that the current token is TK_NUM.
int expect_number() {
  if (token->kind != TK_NUM)
    error_at(token->str, "expected a number");
  int val = token->val;
  token = token->next;
  return val;
}

bool at_eof() {
  return token->kind == TK_EOF;
}

// Create a new token and add it as the next token of `cur`.
Token *new_token(TokenKind kind, Token *cur, char *str) {
  Token *tok = calloc(1, sizeof(Token));
  tok->kind = kind;
  tok->str = str;
  cur->next = tok;
  return tok;
}

// Tokenize `user_input` and returns new tokens.
Token *tokenize() {
  char *p = user_input;
  Token head;
  head.next = NULL;
  Token *cur = &head;

  while (*p) {
    // Skip whitespace characters.
    if (isspace(*p)) {
      p++;
      continue;
    }

    // Punctuator
    if (strchr("+-*/()", *p)) {
      cur = new_token(TK_RESERVED, cur, p++);
      continue;
    }

    // Integer literal
    if (isdigit(*p)) {
      cur = new_token(TK_NUM, cur, p);
      cur->val = strtol(p, &p, 10);
      continue;
    }

    error_at(p, "invalid token");
  }

  new_token(TK_EOF, cur, p);
  return head.next;
}

//
// Parser
//

typedef enum {
  ND_ADD, // +
  ND_SUB, // -
  ND_MUL, // *
  ND_DIV, // /
  ND_NUM, // Integer
} NodeKind;

// AST node type
typedef struct Node Node;
struct Node {
  NodeKind kind; // Node kind
  Node *lhs;     // Left-hand side
  Node *rhs;     // Right-hand side
  int val;       // Used if kind == ND_NUM
};

Node *new_node(NodeKind kind) {
  Node *node = calloc(1, sizeof(Node));
  node->kind = kind;
  return node;
}

Node *new_binary(NodeKind kind, Node *lhs, Node *rhs) {
  Node *node = new_node(kind);
  node->lhs = lhs;
  node->rhs = rhs;
  return node;
}

Node *new_num(int val) {
  Node *node = new_node(ND_NUM);
  node->val = val;
  return node;
}

Node *expr();
Node *mul();
Node *unary();
Node *primary();

// expr = mul ("+" mul | "-" mul)*
Node *expr() {
  Node *node = mul();

  for (;;) {
    if (consume('+'))
      node = new_binary(ND_ADD, node, mul());
    else if (consume('-'))
      node = new_binary(ND_SUB, node, mul());
    else
      return node;
  }
}

// mul = unary ("*" unary | "/" unary)*
Node *mul() {
  Node *node = unary();

  for (;;) {
    if (consume('*'))
      node = new_binary(ND_MUL, node, unary());
    else if (consume('/'))
      node = new_binary(ND_DIV, node, unary());
    else
      return node;
  }
}

// unary = ("+" | "-")? unary
//       | primary
Node *unary() {
  if (consume('+'))
    return unary();
  if (consume('-'))
    return new_binary(ND_SUB, new_num(0), unary());
  return primary();
}

// primary = "(" expr ")" | num
Node *primary() {
  if (consume('(')) {
    Node *node = expr();
    expect(')');
    return node;
  }

  return new_num(expect_number());
}

//
// Code generator
//

void gen(Node *node) {
  if (node->kind == ND_NUM) {
    printf("  push %d\n", node->val);
    return;
  }

  gen(node->lhs);
  gen(node->rhs);

  printf("  pop rdi\n");
  printf("  pop rax\n");

  switch (node->kind) {
  case ND_ADD:
    printf("  add rax, rdi\n");
    break;
  case ND_SUB:
    printf("  sub rax, rdi\n");
    break;
  case ND_MUL:
    printf("  imul rax, rdi\n");
    break;
  case ND_DIV:
    printf("  cqo\n");
    printf("  idiv rdi\n");
    break;
  }

  printf("  push rax\n");
}

int main(int argc, char **argv) {
  if (argc != 2)
    error("%s: invalid number of arguments", argv[0]);

  // Tokenize and parse.
  user_input = argv[1];
  token = tokenize();
  Node *node = expr();

  // Print out the first half of assembly.
  printf(".intel_syntax noprefix\n");
  printf(".global main\n");
  printf("main:\n");

  // Traverse the AST to emit assembly.
  gen(node);

  // A result must be at the top of the stack, so pop it
  // to RAX to make it a program exit code.
  printf("  pop rax\n");
  printf("  ret\n");
  return 0;
}
```

> **注：单目加与文法的优劣**
>
> 原始的C编译器中并没有单目`+`运算符，它是1989年ANSI（美国国家标准协会）对C语言进行标准化时正式添加到语言中的。虽然从对称性角度来说，既然有单目`-`，那么有单目`+`会更好，但实际上单目`+`并没有太多实际用途。
>
> 然而，在文法中添加单目`+`也会带来一些副作用。不熟悉C语言的人可能会误将`+=`运算符写成`i =+ 3`。如果没有单目`+`，这会被视为无效表达式，但由于单目`+`的存在，它会被解释为`i = +3`，即向`i`赋值3的合法赋值表达式，编译器会默默接受这种写法。
>
> ANSI的C语言标准化委员会在了解上述问题的情况下，仍然决定将单目`+`添加到语言中。如果你是当时的委员会成员，会赞成还是反对这一决定呢？

## 步骤7：比较运算符

本节将实现`<`、`<=`、`>`、`>=`、`==`、`!=`这些比较运算符。这些比较运算符虽然看起来有特殊含义，但实际上和`+`、`-`等运算符一样，都是接收两个整数并返回一个整数的双目运算符。就像`+`返回两个操作数相加的结果一样，例如`==`在两个操作数相等时返回1，不相等时返回0。

### 词法分析器的修改

到目前为止，我们处理的符号令牌长度都是1个字符，代码也是基于这个前提编写的。但为了处理`==`等比较运算符，需要对代码进行泛化处理。我们将在`Token`结构体中添加`len`成员，用于保存令牌字符串的长度。新的结构体类型如下：

```c
struct Token {
  TokenKind kind; // 令牌的类型
  Token *next;    // 下一个输入令牌
  int val;        // 当kind为TK_NUM时，表示其数值
  char *str;      // 令牌字符串
  int len;        // 令牌的长度
};
```

随着这一修改，`consume`、`expect`等函数也需要相应调整，使其能够接收字符串而非单个字符。修改后的示例如下：

```c
bool consume(char *op) {
  if (token->kind != TK_RESERVED ||
      strlen(op) != token->len ||
      memcmp(token->str, op, token->len))
    return false;
  token = token->next;
  return true;
}
```

在对由多个字符组成的符号进行词法分析时，需要先对长令牌进行分析。例如，当剩余字符串以`>`开头时，如果不先通过`strncmp(p, ">=", 2)`检查是否为`>=`，而是先检查是否为`>`，就会错误地将`>=`拆分为`>`和`=`两个令牌。

### 新的文法

为了在解析器中添加对比较运算符的支持，我们来思考添加比较运算符后的文法结构。将到目前为止出现的运算符按优先级从低到高排列如下：

1. `==` `!=`
2. `<` `<=` `>` `>=`
3. `+` `-`
4. `*` `/`
5. 单目`+` 单目`-`
6. `()`

优先级可以通过生成文法来表示，优先级不同的运算符会映射到不同的非终结符。参考`expr`、`mul`等的文法，添加比较运算符后的新文法如下：

```bash
expr = equality
equality = relational ("==" relational | "!=" relational)*
relational = add ("<" add | "<=" add | ">" add | ">=" add)*
add = mul ("+" mul | "-" mul)*
mul = unary ("*" unary | "/" unary)*
unary = ("+" | "-")? primary
primary = num | "(" expr ")"
```

其中，`equality`表示`==`和`!=`，`relational`表示`<`、`<=`、`>`、`>=`。这些非终结符可以使用解析左结合运算符的模式，直接映射为相应的函数。

需要说明的是，为了表示整个表达式是`equality`，我们将`expr`和`equality`分开定义。虽然可以将`expr`的右直接写成`equality`的右，但上述文法看起来更清晰。

> **注：简单冗余的代码与高级简洁的代码**
>
> 在递归下降语法分析中，解析规则相似的函数往往具有相似的外观。到目前为止编写的`relational`、`equality`、`add`、`mul`等函数应该也是如此。
>
> 人们自然会想到，能否利用C语言的宏、C++的模板、高阶函数或代码生成等元编程技术，将这些函数中共同的模式抽象出来。实际上，这是可以做到的。但在本书中，我们特意不这样做，原因如下：
>
> 简单的代码即使有些冗余，也容易理解。即使后来需要对这些相似的函数做类似的修改，实际操作起来也不会太麻烦。相反，高度抽象的代码需要先理解其抽象机制，再理解其用法，容易变得晦涩难懂。例如，如果本书从使用元编程技术生成递归下降语法分析的函数开始讲解，那么这本书会变得难得多。
>
> 不必总是追求编写技巧性强且简洁的代码。过度追求这一点，容易将代码复杂化到难以维护的程度。
>
> 代码的编写者往往是代码的专家，容易从专家的角度觉得简洁、无冗余的代码才是好代码。但大多数代码的读者并不具备同样的熟练度，也没有必要达到这种熟练度，因此作为代码的编写者，需要适当怀疑自己的直觉。在必要时，故意编写“看似有更好写法但却很简单的代码”，是编写易于理解、便于维护的程序的重要技巧。

### 汇编代码的生成

在x86-64中，比较操作通过`cmp`指令实现。从栈中弹出两个整数进行比较，当它们相等时将1存入`RAX`，否则存入0，对应的汇编代码如下：

```asm
pop rdi
pop rax
cmp rax, rdi
sete al
movzb rax, al
```

这段汇编代码虽然简短，但包含不少知识点，我们分步来看：

前两行从栈中弹出值。第三行对弹出的两个值进行比较（compare）。比较结果会存储在哪里呢？在x86-64中，比较指令的结果会被设置到特殊的“标志寄存器”中。标志寄存器包含用于表示整数运算结果是否为零、是否有溢出、结果是否小于零等信息的位。

由于标志寄存器不是普通的整数寄存器，若要将比较结果设置到`RAX`中，需要将标志寄存器的特定位复制到`RAX`中。`sete`指令就用于完成这个操作，它在之前的`cmp`指令判断两个寄存器的值相等时，将指定的寄存器（这里是`AL`）设置为1，否则设置为0。

`AL`是本书中尚未出现的新寄存器名，实际上，`AL`只是`RAX`的低8位的别名。因此，当`sete`向`AL`写入值时，`RAX`也会自动更新。但需要注意的是，通过`AL`更新`RAX`时，`RAX`的高56位会保持原值，所以若要将`RAX`整体设置为0或1，需要将高56位清零。`movzb`指令就是用于这个目的的。虽然`sete`能直接写入`RAX`会更方便，但`sete`的设计只允许接收8位寄存器作为参数，因此在比较指令中，需要使用这两条指令来将值设置到`RAX`中。

| 寄存器 | 位数 |
|--------|------|
| RAX    | 64位 |
| AL     | 8位  |

通过使用`sete`之外的其他指令，可以实现其他比较运算符。对于`>`和`>=`，不需要在代码生成器中单独支持，只需在解析器中交换操作数的顺序，将其转换为`<`或`<=`即可。

### 参考实现7

```c
#include <ctype.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

//
// Tokenizer
//

typedef enum {
  TK_RESERVED, // Keywords or punctuators
  TK_NUM,      // Integer literals
  TK_EOF,      // End-of-file markers
} TokenKind;

// Token type
typedef struct Token Token;
struct Token {
  TokenKind kind; // Token kind
  Token *next;    // Next token
  int val;        // If kind is TK_NUM, its value
  char *str;      // Token string
  int len;        // Token length
};

// Input program
char *user_input;

// Current token
Token *token;

// Reports an error and exit.
void error(char *fmt, ...) {
  va_list ap;
  va_start(ap, fmt);
  vfprintf(stderr, fmt, ap);
  fprintf(stderr, "\n");
  exit(1);
}

// Reports an error location and exit.
void error_at(char *loc, char *fmt, ...) {
  va_list ap;
  va_start(ap, fmt);

  int pos = loc - user_input;
  fprintf(stderr, "%s\n", user_input);
  fprintf(stderr, "%*s", pos, ""); // print pos spaces.
  fprintf(stderr, "^ ");
  vfprintf(stderr, fmt, ap);
  fprintf(stderr, "\n");
  exit(1);
}

// Consumes the current token if it matches `op`.
bool consume(char *op) {
  if (token->kind != TK_RESERVED || strlen(op) != token->len ||
      memcmp(token->str, op, token->len))
    return false;
  token = token->next;
  return true;
}

// Ensure that the current token is `op`.
void expect(char *op) {
  if (token->kind != TK_RESERVED || strlen(op) != token->len ||
      memcmp(token->str, op, token->len))
    error_at(token->str, "expected \"%s\"", op);
  token = token->next;
}

// Ensure that the current token is TK_NUM.
int expect_number() {
  if (token->kind != TK_NUM)
    error_at(token->str, "expected a number");
  int val = token->val;
  token = token->next;
  return val;
}

bool at_eof() {
  return token->kind == TK_EOF;
}

// Create a new token and add it as the next token of `cur`.
Token *new_token(TokenKind kind, Token *cur, char *str, int len) {
  Token *tok = calloc(1, sizeof(Token));
  tok->kind = kind;
  tok->str = str;
  tok->len = len;
  cur->next = tok;
  return tok;
}

bool startswith(char *p, char *q) {
  return memcmp(p, q, strlen(q)) == 0;
}

// Tokenize `user_input` and returns new tokens.
Token *tokenize() {
  char *p = user_input;
  Token head;
  head.next = NULL;
  Token *cur = &head;

  while (*p) {
    // Skip whitespace characters.
    if (isspace(*p)) {
      p++;
      continue;
    }

    // Multi-letter punctuator
    if (startswith(p, "==") || startswith(p, "!=") ||
        startswith(p, "<=") || startswith(p, ">=")) {
      cur = new_token(TK_RESERVED, cur, p, 2);
      p += 2;
      continue;
    }

    // Single-letter punctuator
    if (strchr("+-*/()<>", *p)) {
      cur = new_token(TK_RESERVED, cur, p++, 1);
      continue;
    }

    // Integer literal
    if (isdigit(*p)) {
      cur = new_token(TK_NUM, cur, p, 0);
      char *q = p;
      cur->val = strtol(p, &p, 10);
      cur->len = p - q;
      continue;
    }

    error_at(p, "invalid token");
  }

  new_token(TK_EOF, cur, p, 0);
  return head.next;
}

//
// Parser
//

typedef enum {
  ND_ADD, // +
  ND_SUB, // -
  ND_MUL, // *
  ND_DIV, // /
  ND_EQ,  // ==
  ND_NE,  // !=
  ND_LT,  // <
  ND_LE,  // <=
  ND_NUM, // Integer
} NodeKind;

// AST node type
typedef struct Node Node;
struct Node {
  NodeKind kind; // Node kind
  Node *lhs;     // Left-hand side
  Node *rhs;     // Right-hand side
  int val;       // Used if kind == ND_NUM
};

Node *new_node(NodeKind kind) {
  Node *node = calloc(1, sizeof(Node));
  node->kind = kind;
  return node;
}

Node *new_binary(NodeKind kind, Node *lhs, Node *rhs) {
  Node *node = new_node(kind);
  node->lhs = lhs;
  node->rhs = rhs;
  return node;
}

Node *new_num(int val) {
  Node *node = new_node(ND_NUM);
  node->val = val;
  return node;
}

Node *expr();
Node *equality();
Node *relational();
Node *add();
Node *mul();
Node *unary();
Node *primary();

// expr = equality
Node *expr() {
  return equality();
}

// equality = relational ("==" relational | "!=" relational)*
Node *equality() {
  Node *node = relational();

  for (;;) {
    if (consume("=="))
      node = new_binary(ND_EQ, node, relational());
    else if (consume("!="))
      node = new_binary(ND_NE, node, relational());
    else
      return node;
  }
}

// relational = add ("<" add | "<=" add | ">" add | ">=" add)*
Node *relational() {
  Node *node = add();

  for (;;) {
    if (consume("<"))
      node = new_binary(ND_LT, node, add());
    else if (consume("<="))
      node = new_binary(ND_LE, node, add());
    else if (consume(">"))
      node = new_binary(ND_LT, add(), node);
    else if (consume(">="))
      node = new_binary(ND_LE, add(), node);
    else
      return node;
  }
}

// add = mul ("+" mul | "-" mul)*
Node *add() {
  Node *node = mul();

  for (;;) {
    if (consume("+"))
      node = new_binary(ND_ADD, node, mul());
    else if (consume("-"))
      node = new_binary(ND_SUB, node, mul());
    else
      return node;
  }
}

// mul = unary ("*" unary | "/" unary)*
Node *mul() {
  Node *node = unary();

  for (;;) {
    if (consume("*"))
      node = new_binary(ND_MUL, node, unary());
    else if (consume("/"))
      node = new_binary(ND_DIV, node, unary());
    else
      return node;
  }
}

// unary = ("+" | "-")? unary
//       | primary
Node *unary() {
  if (consume("+"))
    return unary();
  if (consume("-"))
    return new_binary(ND_SUB, new_num(0), unary());
  return primary();
}

// primary = "(" expr ")" | num
Node *primary() {
  if (consume("(")) {
    Node *node = expr();
    expect(")");
    return node;
  }

  return new_num(expect_number());
}

//
// Code generator
//

void gen(Node *node) {
  if (node->kind == ND_NUM) {
    printf("  push %d\n", node->val);
    return;
  }

  gen(node->lhs);
  gen(node->rhs);

  printf("  pop rdi\n");
  printf("  pop rax\n");

  switch (node->kind) {
  case ND_ADD:
    printf("  add rax, rdi\n");
    break;
  case ND_SUB:
    printf("  sub rax, rdi\n");
    break;
  case ND_MUL:
    printf("  imul rax, rdi\n");
    break;
  case ND_DIV:
    printf("  cqo\n");
    printf("  idiv rdi\n");
    break;
  case ND_EQ:
    printf("  cmp rax, rdi\n");
    printf("  sete al\n");
    printf("  movzb rax, al\n");
    break;
  case ND_NE:
    printf("  cmp rax, rdi\n");
    printf("  setne al\n");
    printf("  movzb rax, al\n");
    break;
  case ND_LT:
    printf("  cmp rax, rdi\n");
    printf("  setl al\n");
    printf("  movzb rax, al\n");
    break;
  case ND_LE:
    printf("  cmp rax, rdi\n");
    printf("  setle al\n");
    printf("  movzb rax, al\n");
    break;
  }

  printf("  push rax\n");
}

int main(int argc, char **argv) {
  if (argc != 2)
    error("%s: invalid number of arguments", argv[0]);

  // Tokenize and parse.
  user_input = argv[1];
  token = tokenize();
  Node *node = expr();

  // Print out the first half of assembly.
  printf(".intel_syntax noprefix\n");
  printf(".global main\n");
  printf("main:\n");

  // Traverse the AST to emit assembly.
  gen(node);

  // A result must be at the top of the stack, so pop it
  // to RAX to make it a program exit code.
  printf("  pop rax\n");
  printf("  ret\n");
  return 0;
}
```

> **注：标志寄存器与硬件视角**
>
> x86-64中，比较结果会被隐式地存储在与普通整数寄存器不同的特殊寄存器中，这一特性初看起来可能难以理解。实际上，有些RISC处理器为了避免使用标志寄存器，会将比较结果直接设置到普通寄存器中，例如RISC-V就是这样的指令集。
>
> 但从硬件实现的角度来看，实现标志寄存器其实非常简单。在进行整数运算时，只需将结果的线路分叉连接到另一个逻辑电路，通过该电路判断结果是否为零（所有线路是否为0）、结果是否为负数（最高位线路是否为1）等，并将这些判断结果设置到标志寄存器的各个位上即可。具有标志寄存器的CPU正是采用这种实现方式，在进行整数运算的同时，会顺带更新标志寄存器。
>
> 基于这种机制，不仅`cmp`指令，`add`、`sub`等指令也会更新标志寄存器。实际上，`cmp`本质上是一种特殊的`sub`指令，它只更新标志寄存器而不修改整数寄存器的值。如果执行`sub rax, rdi`后查看标志寄存器，就能知道`RAX`和`RDI`的大小关系，但这样会修改`RAX`的值，因此为了避免这种情况，就有了`cmp`指令。
>
> 在软件中，“顺带计算某事”必然会花费额外时间，但在硬件中，通过线路分叉使用额外的晶体管并不会带来时间上的惩罚，因此在简单的硬件实现中，每次更新标志寄存器并不会产生额外成本。
