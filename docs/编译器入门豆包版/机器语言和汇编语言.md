# 机器语言和汇编语言

本章旨在让读者大致了解计算机的组成部分，以及我们将要制作的C编译器需要输出什么样的代码。暂时不会深入探讨具体的CPU指令，首先掌握概念更为重要。

## CPU与内存

计算机的组成部分大致可分为CPU和内存。内存是能够存储数据的设备，CPU则是在读写内存的同时进行各种处理的设备。

从概念上讲，在CPU看来，内存就像一个可以随机访问的巨大字节数组。CPU访问内存时，会用数值指定要访问内存的第几个字节，这个数值被称为“地址”。例如，“从地址16读取8字节的数据”，意思就是从像字节数组一样的内存中，读取从第16字节开始的8字节数据。也可以表述为“从16号地址读取8字节的数据”。

CPU执行的程序和程序读写的数据都存放在内存中。CPU内部会保存“当前正在执行的指令的地址”，从该地址读取指令并执行，然后读取下一条指令继续执行，周而复始。这个当前正在执行的指令的地址被称为“程序计数器”（PC，Program Counter）或“指令指针”（IP，Instruction Pointer）。CPU执行的程序本身的形式被称为“机器语言”（machine code）。

程序计数器并非总是直线式地指向下一条指令。使用CPU的“分支指令”（branch instruction），可以将程序计数器设置为除下一条指令之外的任意地址。正是依靠这一功能，才能实现if语句、循环等结构。将程序计数器设置到非下一条指令的位置，称为“跳转”或“分支”。

除了程序计数器，CPU还有少量的数据存储区域。例如，Intel和AMD的处理器有16个可存储64位整数的区域，这种区域被称为“寄存器”（register）。内存对于CPU来说是外部设备，读写需要一定时间，而寄存器位于CPU内部，可以无延迟地访问。

许多机器语言的指令形式是：使用两个寄存器的值进行某种运算，然后将结果写回寄存器。因此，程序的执行过程可以理解为：CPU从内存将数据读入寄存器，在寄存器之间进行运算，再将结果写回内存，以此推动程序运行。

特定机器语言的指令集合被统称为“指令集架构”（ISA，Instruction Set Architecture）或“指令集”。指令集并非只有一种，不同的CPU可以按自己的意愿设计。但如果机器语言层面不兼容，就无法运行相同的程序，因此指令集的变种并不多。在PC领域，Intel及其兼容厂商AMD所使用的“x86-64”指令集是主流之一。不过x86-64并未垄断市场，例如iPhone和Android设备使用的是名为ARM的指令集。

> **注：x86-64指令集的名称**
>
> x86-64也被称为AMD64、Intel 64、x64等，同一指令集有多个名称，这背后有其历史原因。
>
> x86指令集由Intel于1978年推出，而将其扩展为64位的是AMD。2000年左右，64位处理器的需求逐渐显现，当时Intel全力投入名为Itanium的全新指令集，并未涉足与之竞争的64位版x86。AMD抓住这个机会，制定并公开了64位版x86的规格，这就是x86-64。后来，出于品牌战略等原因，AMD将其改名为AMD64。
>
> 之后，Itanium的失败日益明显，Intel除了开发64位版x86外别无选择。但当时AMD64的处理器已经有了一定的市场份额，再另起炉灶制定类似却不兼容的扩展指令集已不现实，因此Intel也采用了与AMD兼容的指令集，并将其命名为IA-32e（Intel Architecture 32 extensions）。名称中不用64而用IA-32e，隐约体现了Intel对未能成功的Itanium这一64位CPU的留恋。后来，Intel完全放弃了Itanium，IA-32e也改名为更普通的Intel 64。而微软则嫌名称过长，将x86-64称为x64。
>
> 由于上述原因，x86-64有多个不同的名称。
>
> 在开源项目中，通常更倾向使用不包含特定公司名称的x86-64这一名称，本书也将统一使用x86-64。

## 什么是汇编语言

机器语言是CPU直接读取执行的语言，只考虑了CPU的便利性，完全不考虑人类的易用性。汇编语言是将这种机器语言用二进制数据表示出来的语言，它与机器语言几乎是一一对应的，但比机器语言更容易被人类阅读。

对于输出原生二进制代码而非虚拟机或解释器代码的编译器来说，通常以输出汇编语言为目标。即使看起来是直接输出机器语言的编译器，在常见结构中，也是先输出汇编语言，再通过汇编器将其转换为机器语言。本书制作的C编译器也将输出汇编语言。

将汇编代码转换为机器语言的过程有时也称为“编译”，但为了强调输入是汇编语言，特别称为“汇编”（assemble）。

读者可能在某处见过汇编语言，如果没有见过，现在正是了解的好机会。使用objdump命令对任意可执行文件进行反汇编，可以将文件中的机器语言以汇编语言的形式显示出来。以下是对ls命令进行反汇编的结果：

```bash
$ objdump -d -M intel /bin/ls
/bin/ls:     file format elf64-x86-64

Disassembly of section .init:
0000000000003d58 <_init@@Base>:
  3d58:  48 83 ec 08          sub    rsp,0x8
  3d5c:  48 8b 05 7d b9 21 00 mov    rax,QWORD PTR [rip+0x21b97d]
  3d63:  48 85 c0             test   rax,rax
  3d66:  74 02                je     3d6a <_init@@Base+0x12>
  3d68:  ffd0                call   rax
  3d6a:  48 83 c4 08          add    rsp,0x8
  3d6e:  c3                   ret
```

在笔者的环境中，ls命令包含约2万个机器语言指令，反汇编后会显示大量内容。我们来看其中一行：

```asm
3d58:  48 83 ec 08          sub    rsp,0x8
```

这行的含义是什么呢？3d58是存放机器语言的内存地址，也就是说，当ls命令执行时，这行指令位于内存的0x3d58地址，当程序计数器指向0x3d58时，就会执行这条指令。后面跟着的4个十六进制数值是实际的机器语言，CPU读取这些数据并作为指令执行。sub rsp,0x8是与该机器语言指令对应的汇编代码。关于CPU指令集，我们会另设章节说明，这条指令的作用是从RSP寄存器中减去8（subtract = 减去）。

## C语言及其对应的汇编语言

### 简单示例

为了了解C编译器输出的内容，我们来对比C代码及其对应的汇编代码。最筒单的例子是下面的C程序：

```c
int main() {
  return 42;
}
```

将这个程序所在的文件命名为test1.c，通过以下方式编译，并确认main函数确实返回42：

```bash
$ cc -o test1 test1.c
$ ./test1
$ echo $?
42
```

在C语言中，main函数的返回值会成为程序的退出码。程序的退出码不会显示在屏幕上，但会隐式地设置到shell的$?变量中，因此在命令执行后立即用echo显示$?，就能看到该命令的退出码，这里正确返回了42。

对应这个C程序的汇编程序如下：

```asm
.intel_syntax noprefix
.globl main
main:
    mov rax, 42
    ret
```

这段汇编代码定义了全局标签main，标签后面是main函数的代码。这里将42这个值存入RAX寄存器，然后从main函数返回。包括RAX在内，共有16个可存储整数的寄存器，按照约定，函数返回时RAX中存放的值就是函数的返回值，因此这里将值存入RAX。

汇编文件的扩展名是.s，将上面的汇编代码写入test2.s，执行以下命令：

```bash
$ cc -o test2 test2.s
$ ./test2
$ echo $?
42
```

和C语言的情况一样，退出码是42。

大致来说，C编译器就是读取像test1.c这样的C代码，输出像test2.s这样的汇编代码的程序。

### 包含函数调用的示例

再看一个稍复杂的例子，看看包含函数调用的代码会被转换为怎样的汇编代码。

函数调用与单纯的跳转不同，调用的函数执行结束后，必须返回到原来执行的位置。原来执行的位置的地址称为“返回地址”。如果函数调用只有一层，返回地址可以存放在CPU的某个寄存器中，但函数调用可以嵌套任意多层，因此返回地址需要存放在内存中。实际上，返回地址存放在内存的栈中。

栈可以仅通过一个变量来实现，这个变量保存栈顶的地址，称为“栈指针”。x86-64为了支持使用函数的编程方式，提供了专门用于栈指针的寄存器和使用该寄存器的指令。将数据放入栈称为“入栈”（push），从栈中取出数据称为“出栈”（pop）。

来看一个函数调用的实例，考虑下面的C代码：

```c
int plus(int x, int y) {
    return x + y;
}

int main() {
    return plus(3, 4);
}
```

对应的汇编代码如下：

```asm
.intel_syntax noprefix
.globl plus, main
plus:
    add rsi, rdi
    mov rax, rsi
    ret
main:
    mov rdi, 3
    mov rsi, 4
    call plus
    ret
```

第1行是指定汇编语法的指令。第2行以.globl开头的行，向汇编器指示plus和main这两个函数是全局可见的（而非仅在文件范围内可见），暂时可以忽略这一点。

先关注main函数。在C代码中，main函数带参数调用plus函数。在汇编中，约定第一个参数放入RDI寄存器，第二个参数放入RSI寄存器，因此main函数的前两行按此约定设置值。

call是调用函数的指令，具体来说，call会执行以下操作：

1. 将call的下一条指令（此处是ret）的地址入栈
2. 跳转到作为call参数的地址

因此，执行call指令后，CPU开始执行plus函数。

再看plus函数，它包含三条指令：

add是加法指令，这里将RSI寄存器和RDI寄存器的值相加，结果写入RSI寄存器。x86-64的整数运算指令通常只接受两个寄存器，因此结果会以覆盖第一个参数寄存器值的形式保存。

如前所述，函数的返回值要放入RAX寄存器，因此需要将RSI中的值复制到RAX，这里使用mov指令实现。mov是move的缩写，但实际上并非移动数据，只是复制指令。

plus函数的最后调用ret指令从函数返回，ret具体执行以下操作：

1. 从栈中弹出一个地址
2. 跳转到该地址

也就是说，ret指令会还原call所做的操作，恢复调用方函数的执行。call和ret是一对相互配合的指令。

从plus返回后，main函数中剩下的是ret指令。在原来的C代码中，main函数将plus的返回值直接返回。由于此时plus的返回值已存放在RAX中，因此main函数直接返回即可，该值会成为main函数的返回值。

## 本章总结

本章介绍了计算机内部的工作原理以及C编译器的作用。对于初次接触汇编代码的读者来说，它可能看起来像是一堆杂乱无章的数据，但实际上，它意外地直接反映了C语言的结构。

由于本书尚未对具体的机器语言进行太多说明，读者可能还无法完全理解objdump显示的内容，但在本章阶段，能有这种感觉就足够了。

本章要点总结如下：

- CPU通过读写内存来推动程序执行
- CPU执行的程序和程序处理的数据都存放在内存中，CPU从内存依次读取机器语言指令并执行
- CPU有称为寄存器的小型存储区域，许多机器语言指令定义为寄存器之间的操作
- 汇编语言是将机器语言转换为人类易读形式的语言，C编译器通常输出汇编语言
- C语言的函数在汇编语言中也表现为函数
- 函数调用通过栈来实现

> **注：在线编译器**
>
> 查看C代码及其编译结果是学习汇编语言的好方法，但反复编辑源代码、编译并确认输出的汇编代码，意外地繁琐。有一个非常好的网站可以减少这种麻烦，那就是Compiler Explorer（俗称godbolt）。在Compiler Explorer的左侧文本框输入代码，右侧会实时显示对应的汇编输出。想要确认C代码会被转换为怎样的汇编代码时，使用这个网站很方便。
