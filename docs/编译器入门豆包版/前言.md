# 前言

本书是一部在线书籍，目前仍在撰写中，并非完成版。您可以通过Feedburner订阅更新。

本书收录的内容有些“贪心”，远超一般单本书籍的承载量。在本书中，我们将制作一个能把C语言源代码转换为汇编语言的程序——也就是C编译器，而编译器本身也将用C语言开发。我们的近期目标是实现“自举”（self-host），即能用自己开发的编译器编译其自身的源代码。

为了避免编译器的讲解难度骤升，本书将通过各种主题，以逐步深入的方式进行说明。原因如下：

编译器在概念上可以分为语法解析、中间代码、代码生成等多个阶段。常见的教科书式方法会为每个主题分章讲解，但这种方式容易让内容在中途变得过于狭隘和深入，导致读者难以跟上。

此外，按阶段开发的方法存在一个问题：在所有阶段完成之前，无法运行编译器，因此即便自己的理解或代码存在根本性错误，也难以察觉。而且，在开始前一阶段时，往往不清楚下一阶段需要什么样的输入，也就不知道前一阶段应该输出什么。在完全完成前，无法编译任何代码，这会导致难以保持动力。

为了避开这个陷阱，本书将采用另一种方法。在本书的开头，读者将实现一个语法规则极其简单的“自创语言”。由于这种语言非常简单，在实现时无需深入了解编译器的制作方法。之后，读者将通过本书不断为“自创语言”添加功能，最终将其打造成与C语言一致的语言。

通过这种增量开发方法，我们将一步步地、分阶段地制作编译器。在这种开发方法中，无论哪个阶段，编译器在某种意义上都是“完成态”。某个阶段可能只能实现计算器级别的功能，某个阶段可能只是C语言的一个有限子集，某个阶段可能已经是几乎与C语言相当的语言。关键在于，每个阶段都以符合当前完成度的、合理的语言规则为目标。开发过程中，我们不会只为突出部分功能而刻意模仿C语言的特性。

数据结构、算法以及计算机科学相关知识也将根据开发阶段逐步讲解。

通过增量开发，在阅读本书的任何时刻，读者都能均衡掌握当前阶段所需的语言制作知识。这远好于只精通编译器制作的某一部分知识的状态。当读完本书时，读者应该能均衡掌握所有主题的知识。

此外，本书也将讲解如何从零开始编写大型程序。编写大型程序的技能与学习数据结构和算法不同，是一种独特的技能，但讲解这种技能的书籍并不多。而且，即便有人讲解，若不亲自体验，也很难理解开发方法的优劣。本书设计的“将自创语言逐步打造成C语言”的过程，将成为一种良好开发方法的实践体验。

如果笔者的计划成功，通过阅读本书，读者不仅能学到编译器制作技术和CPU指令集的知识，还能学到将大型程序拆分为小步骤、逐步实现的方法，以及软件测试技巧、版本管理方法，甚至是应对编译器开发这类具有挑战性的项目时的心态。

本书的目标读者是普通的C程序员。无需是精通C语言规格的超级C程序员，只要能理解指针和数组，并且至少能花时间读懂他人编写的小规模C程序，就完全足够。

在撰写本书时，对于语言规格和CPU规格，笔者不仅会解释规格本身，还会尽可能讲解为何选择这样的设计。此外，还会穿插一些关于编译器、CPU、计算机行业及其历史的趣闻，希望能让读者轻松愉快地阅读。

制作编译器是一件非常有趣的工作。最初只能进行极其简单操作的自创语言，随着开发的推进，会突然变得越来越像C语言，像魔法一样顺畅运行。实际开发时，常常会惊讶地发现，原本以为无法编译的较大测试代码竟然能毫无错误地编译并正确运行，甚至查看编译出的汇编代码时，自己都不能立刻理解。有时，甚至会感觉自己开发的编译器拥有超越开发者自身的智慧。即便了解编译器的工作原理，它为何能如此顺畅地运行，总会让人觉得不可思议。相信你也会为这种魅力而着迷。

好了，前言就到这里，让我们一起踏入编译器开发的世界吧！

在众多编程语言中，本书为何选择C语言？或者说，为何不选择自创语言？其实，并非非C语言不可，但如果要学习生成原生机器码的编译器制作方法，C是为数不多的合理选择之一。

解释型语言难以让我们学到太多关于低级层面的知识。而C语言通常会被编译为汇编语言，因此通过制作编译器，我们能同时学习C语言本身以及CPU指令集、程序运行机制等知识。

C语言应用广泛，当编译器能正常工作后，你可以编译从网上下载的第三方源代码来“玩”。例如，你可以编译迷你Unix系统xv6。如果编译器的完成度足够高，甚至可能编译Linux内核。这种乐趣是主流语言或自创语言无法提供的。

与C类似的、会被编译为原生机器码的静态类型语言中，C++也被广泛使用。但C++的语言规格过于庞大，要轻松制作出自创编译器几乎不可能，因此实际上不会被列入选择范围。

从打磨语言设计感的角度来说，设计并实现原创语言是不错的，但也存在陷阱：对于实现麻烦的地方，可以通过调整语言规格来避免实现。而像C这样有标准规格的语言则不行，这种约束在学习层面其实是有益的。

## 本书的记法

函数、表达式、命令等在正文中将以等宽字体显示，例如`main`、`foo=3`、`make`。

多行代码将使用等宽字体并放在框中，如下所示：

```c
int main() {
  printf("Hello world!\n");
  return 0;
}
```

如果框中的代码是用户需要直接输入的shell命令，那么以`$`开头的行表示提示符，只需输入`$`后的内容（不要输入`$`本身）。`$`以外的行表示命令的输出。例如，下面的代码块展示了用户输入`make`并按下回车后的执行示例，`make`命令的输出是`make: Nothing to be done for 'all'.`。

```bash
$ make
make: Nothing to be done for 'all'.
```

## 本书的开发环境

本书假设使用Intel或AMD等常见PC上的64位Linux环境。请读者根据自己的发行版，预先安装gcc、make等开发工具。如果是Ubuntu，可以通过以下命令安装本书中使用的命令：

```bash
sudo apt update
sudo apt install -y gcc make git binutils libc6-dev
```

macOS与Linux在汇编层面有一定兼容性，但并非完全兼容（具体来说，不支持“静态链接”功能）。虽然并非不可能基于本书内容制作支持macOS的C编译器，但实际尝试时，会在细节上遇到各种兼容性问题。同时学习编译器制作技术和macOS与Linux的差异，并不是推荐的做法——当出现问题时，你很难分辨是对哪个部分的理解出了错。

因此，本书不支持macOS。使用macOS的读者请通过某种虚拟环境准备Linux环境。对于首次准备Linux虚拟环境的读者，附录3中总结了使用Docker创建开发环境的方法，可供参考。

Windows与Linux在汇编层面完全不兼容。不过，Windows 10支持在Windows上像应用程序一样运行Linux，借助这一功能可以在Windows上进行开发。这个Linux兼容环境名为Windows Subsystem for Linux（WSL）。在Windows上实践本书内容时，请安装WSL，并在其中进行开发。

> **注：交叉编译器**
>
> 运行编译器的机器称为“宿主”（host），运行编译器输出代码的机器称为“目标”（target）。本书中两者都是64位Linux环境，但宿主和目标不一定必须相同。
>
> 宿主和目标不同的编译器称为“交叉编译器”。例如，在Windows上运行、生成Raspberry Pi可执行文件的编译器就是交叉编译器。当目标机器运行编译器的性能不足或较为特殊时，经常会使用交叉编译器。

## 作者简介

植山 类（@rui314）。高速链接器lld的原创作者及现任维护者，lld已被Android（版本Q及以上）、FreeBSD（12及以上）、Nintendo Switch、Chrome、Firefox等众多操作系统和项目采用作为生成可执行文件的标准链接器（可信度高）。同时也是轻量C编译器8cc的作者。关于软件测试的随笔主要写在note上。

> **注：编译编译器的编译器**
> 像 C 编译器用 C 语言编写这样的自引用情况并不罕见。除 C 之外，许多语言的实现也是用该语言本身编写的。
> 如果已有某语言 X 的实现，那么用 X 语言编写新的 X 编译器在逻辑上并无矛盾。如果想实现自举，只需用现有编译器进行开发，完成后切换到自己的编译器即可。这正是我们在本书中要做的事情。
> 但如果没有现有编译器呢？这时就只能用其他语言编写。若想用 X 语言实现自举，编写 X 语言的第一个编译器时，需使用与 X 不同的现有语言 Y，当编译器的完成度足够高后，再将编译器从 Y 语言重写为 X 语言。
> 现代复杂编程语言的编译器，追溯其谱系，最终都能回到计算机黎明时期某人用机器码直接编写的简单汇编器。虽然现存的所有语言实现是否源自单一或多个原始汇编器尚不明确，但毫无疑问，当前的编译器都源自少数几个祖先。由于除编译器外的可执行文件通常也是由编译器生成的，因此现存的几乎所有可执行文件都是这些原始汇编器的间接后代。这就像生命的起源一样有趣。
